{% extends "base.html" %} {% block content %}
<div class="panel">
  <div class="panel-header" style="display:flex; align-items:center; justify-content:space-between">
    <div class="header-left">
      <h1>Importer</h1>
      <div class="muted">
        Configure facility, experiment, dates, times, and cameras.
      </div>
    </div>
  </div>
  <div class="controls">
    <div class="control-group">
      <label for="source-dir">Source Folder</label>
      <div style="display: flex; gap: 8px; align-items: center">
        <input id="source-dir" type="text" readonly placeholder="Select a facility" style="flex: 1" />
        <button class="btn" id="list-btn" title="List all files per camera with progress">
          List
        </button>
      </div>
    </div>

    <div class="control-group">
      <label for="experiment-select">Experiment</label>
      <select id="experiment-select" disabled></select>
    </div>
    <div class="control-group">
      <label for="treatment-select">Treatment</label>
      <select id="treatment-select" disabled></select>
    </div>

    <div class="control-group">
      <label for="batch-input">Batch</label>
      <input id="batch-input" type="number" min="0" step="1" value="1" readonly />
    </div>

    <div class="control-group">
      <label for="start-date">Start Date</label>
      <input id="start-date" type="date" />
    </div>
    <div class="control-group">
      <label for="end-date">End Date</label>
      <input id="end-date" type="date" />
    </div>

    <div class="control-group">
      <label for="start-time">Start Time</label>
      <input id="start-time" type="time" placeholder="20:00" />
    </div>
    <div class="control-group">
      <label for="end-time">End Time</label>
      <input id="end-time" type="time" />
    </div>

    <div class="control-group" style="grid-column: 1 / -1">
      <label>Cameras</label>
      <div id="cameras-wrap">
        <div id="cams-topline" style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
          ">
          <div class="cam-toolbar" id="cams-toolbar" hidden>
            <button type="button" class="btn mini" id="cams-all">All</button>
            <button type="button" class="btn mini" id="cams-none">None</button>
            <div class="cam-row" id="cams-row"></div>
          </div>
          <div style="
              display: flex;
              align-items: center;
              gap: 8px;
              flex-wrap: wrap;
            ">
            <button class="btn" id="list-import-btn" title="List files that match your selection">
              List
            </button>
            <button class="btn primary" id="open-import" title="Open import dialog">
              Import
            </button>
          </div>
        </div>
      </div>
      <div class="muted" id="cameras-hint" style="margin-top: 6px">
        Select a facility to load available cameras.
      </div>
    </div>
  </div>
</div>

<!-- Import Modal -->
<div id="import-modal" style="
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.4);
    z-index: 1000;
    align-items: center;
    justify-content: center;
    padding: 24px;
  ">
  <div class="panel" style="
      margin: 0;
      width: min(1100px, 96vw);
      max-height: 90vh;
      overflow: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      border-radius: 10px;
    ">
    <div class="panel-header" style="display: flex; align-items: center; justify-content: space-between">
      <div style="display: flex; align-items: center; gap: 8px">
        <button class="btn" id="import-close" title="Close" style="
            font-weight: 700;
            width: 32px;
            height: 32px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
          ">
          ✕
        </button>
        <h1 style="margin: 0">Import</h1>
      </div>
      <div style="display: flex; gap: 8px; align-items: center">
        <button class="btn primary" id="import-btn" disabled title="Complete selections to enable scan">
          Rescan
        </button>
        <button class="btn" id="run-btn" disabled title="Run is available after a successful scan">
          Run
        </button>
      </div>
    </div>
    <div id="import-modal-body" style="padding: 8px 12px"></div>
  </div>
</div>

<script>
  window.addEventListener("DOMContentLoaded", function () {
    const CFG = window.CHEESEPIE || {};
    const FACS = (CFG.importer && CFG.importer.facilities) || {};

    const $ = (s, el = document) => el.querySelector(s);
    const facilitySel = document.getElementById("app-facility");
    const experimentSel = $("#experiment-select");
    const treatmentSel = $("#treatment-select");
    const srcDir = $("#source-dir");
    const startDate = $("#start-date");
    const endDate = $("#end-date");
    const startTime = $("#start-time");
    const endTime = $("#end-time");
    const camsWrap = $("#cameras-wrap");
    const camsToolbar = $("#cams-toolbar");
    const camsRow = $("#cams-row");
    const camsAllBtn = $("#cams-all");
    const camsNoneBtn = $("#cams-none");
    const batchInput = $("#batch-input");
    const listBtn = document.getElementById("list-btn");
    const camsHint = $("#cameras-hint");
    const importBtn = document.getElementById("import-btn");
    const listImportBtn = document.getElementById("list-import-btn");
    const openImportBtn = document.getElementById('open-import');
    const runTopBtn = document.getElementById("run-btn");
    let scanController = null;
    let scanAnimTimer = null;
    let scanDotsTimer = null;
    let scanDotsBase = "";
    let scanAutoRun = true;
    let scanMode = "import";
    let scanFilterInRange = false;
    let scanSeenPaths = new Set();

    function loadScanMode() {
      let mode = "import";
      try { mode = localStorage.getItem('cheesepie.scan_mode') || 'import'; } catch { }
      scanMode = mode === "list" || mode === "list-filtered" ? mode : "import";
      scanAutoRun = scanMode === "import";
      scanFilterInRange = scanMode === "list-filtered";
    }

    function setScanMode(mode) {
      if (mode === "list-filtered") {
        scanMode = "list-filtered";
        scanFilterInRange = true;
      } else if (mode === "list") {
        scanMode = "list";
        scanFilterInRange = false;
      } else {
        scanMode = "import";
        scanFilterInRange = false;
      }
      scanAutoRun = scanMode === "import";
      try { localStorage.setItem('cheesepie.scan_mode', scanMode); } catch { }
    }

    function clearScanMode() {
      scanMode = "import";
      scanAutoRun = true;
      scanFilterInRange = false;
      try { localStorage.removeItem('cheesepie.scan_mode'); } catch { }
    }

    function setListBtnState(state) {
      if (!listBtn) return;
      if (state === "running") {
        listBtn.disabled = true;
        listBtn.textContent = "Listing…";
      } else if (state === "disabled") {
        listBtn.disabled = true;
        listBtn.textContent = "List";
      } else {
        listBtn.disabled = false;
        listBtn.textContent = "List";
      }
    }

    function setListImportBtnState(state) {
      if (!listImportBtn) return;
      if (state === "running") {
        listImportBtn.disabled = true;
        listImportBtn.textContent = "Listing…";
      } else if (state === "disabled") {
        listImportBtn.disabled = true;
        listImportBtn.textContent = "List";
      } else {
        listImportBtn.disabled = false;
        listImportBtn.textContent = "List";
      }
    }

    function setImportBtnStateIdle() {
      if (!openImportBtn) return;
      openImportBtn.disabled = false;
      openImportBtn.textContent = "Import";
      openImportBtn.style.background = "";
      openImportBtn.style.color = "";
      openImportBtn.dataset.running = "0";
      openImportBtn.title = "";
    }

    function setImportBtnStateScanning() {
      if (!openImportBtn) return;
      openImportBtn.disabled = true;
      openImportBtn.textContent = "Scanning…";
      openImportBtn.style.background = "";
      openImportBtn.style.color = "";
      openImportBtn.dataset.running = "0";
      openImportBtn.title = "Scan in progress";
    }
    // Resume any in-progress scan/encode when returning to Importer
    async function resumeJobs() {
      try {
        loadScanMode();
        let jid = null;
        try { const cur = await fetch('/api/import/scan_prepare/current').then(r => r.json()).catch(() => null); if (cur && cur.ok && cur.job_id) jid = cur.job_id; } catch { }
        if (!jid) { try { jid = localStorage.getItem('cheesepie.scan_job') || ''; } catch { } }
        if (jid) {
          window.__SCAN_JOB_ID__ = jid;
          ensureScanPanel(); ensureDaysPanel();
          if (scanMode === "list") {
            setListBtnState("running");
            setListImportBtnState("disabled");
          } else if (scanMode === "list-filtered") {
            setListImportBtnState("running");
            setListBtnState("disabled");
          } else {
            setImportBtnStateScanning();
            setListBtnState("disabled");
            setListImportBtnState("disabled");
          }
          try { if (scanPollTimer) { clearInterval(scanPollTimer); } } catch { }
          // Make sure the Available Files panel is visible when resuming
          try {
            const content = document.getElementById('scan-content');
            const btn = document.getElementById('scan-toggle-btn');
            const panel = document.getElementById('import-scan');
            if (content) { content.style.display = 'block'; }
            if (btn) { btn.textContent = 'Hide'; }
            if (panel) { panel.dataset.collapsed = '0'; }
          } catch { }
          scanPollTimer = setInterval(() => { pollScanStatus(jid); }, 1000);
          // Trigger an immediate poll instead of waiting for the first interval
          try { await pollScanStatus(jid); } catch { }
        }
      } catch { }
      try {
        let ejid = null; try { ejid = localStorage.getItem('cheesepie.encode_job') || ''; } catch { }
        if (ejid) {
          encodeJobId = ejid; try { window.__ENCODE_JOB_ID__ = ejid; } catch { };
          // Reflect Stop/Cancel state on the top Import button
          try { const btn = document.getElementById('open-import'); if (btn) { btn.disabled = false; btn.textContent = 'Cancel'; btn.style.background = '#b71c1c'; btn.style.color = '#fff'; btn.dataset.running = '1'; } } catch { }
          pollEncode();
        }
      } catch { }
    }

    // Ensure panels exist immediately so resume shows something without clicks
    try { ensureScanPanel(); ensureDaysPanel(); } catch (e) { }
    // Default the scan panel to hidden on load (user can expand with "Show")
    try {
      const content = document.getElementById('scan-content');
      const btn = document.getElementById('scan-toggle-btn');
      const panel = document.getElementById('import-scan');
      if (content) { content.style.display = 'none'; }
      if (btn) { btn.textContent = 'Show'; }
      if (panel) { panel.dataset.collapsed = '1'; }
    } catch (e) { }

    function pad2(n) {
      return String(n).padStart(2, "0");
    }

    function ensureErrorBanner() {
      let eb = document.getElementById("error-banner");
      if (!eb) {
        eb = document.createElement("div");
        eb.id = "error-banner";
        eb.style.cssText =
          "display:none; margin:10px 0; padding:8px 12px; border-radius:6px; background:#ffebee; color:#b71c1c; border:1px solid #ef9a9a;";
        const container =
          document.querySelector(".panel .controls") || document.body;
        container.parentElement.insertBefore(eb, container);
      }
      return eb;
    }
    function hideErrorBanner() {
      try {
        const eb = document.getElementById("error-banner");
        if (eb) { eb.style.display = 'none'; eb.textContent = ''; }
      } catch { }
    }
    function parseStackLoc(err) {
      try {
        const st = String((err && err.stack) || "").split("");
        for (const line of st) {
          const m = line.match(/([^\s\(]+):(\d+):(\d+)/);
          if (m) {
            return { file: m[1], line: Number(m[2]), col: Number(m[3]) };
          }
        }
      } catch { }
      return null;
    }
    function showError(context, err) {
      const eb = ensureErrorBanner();
      const msg = err && err.message ? err.message : String(err);
      const loc = parseStackLoc(err);
      const locTxt = loc ? ` (at ${loc.file}:${loc.line}:${loc.col})` : "";
      eb.textContent = `${context}: ${msg}${locTxt}`;
      eb.style.display = "block";
      try {
        console.error(context, err);
      } catch { }
    }
    window.addEventListener("error", (e) => {
      showError("Unhandled error", (e && e.error) || e.message);
    });
    window.addEventListener("unhandledrejection", (e) => {
      showError("Unhandled promise", (e && e.reason) || "");
    });

    function formatDate(d) {
      const y = d.getFullYear();
      const m = pad2(d.getMonth() + 1);
      const day = pad2(d.getDate());
      return `${y}-${m}-${day}`;
    }

    function combinedSourcePattern(fac) {
      const f = FACS[fac] || {};
      const src = (f && f.source_dir) || "";
      const glob = (f && (f.camera_pattern || f.camera_glob)) || "";
      if (!src) return "";
      if (!glob) return src;
      if (/^\//.test(glob)) return glob;
      return src.replace(/\/+$/, "") + "/" + glob.replace(/^\/+/, "");
    }

    function getSelectedCameras() {
      return Array.from(camsRow.querySelectorAll(".cam-btn.active"))
        .map((x) => Number(x.dataset.cam))
        .filter((n) => Number.isFinite(n));
    }

    function setSelectedCameras(list) {
      const want = new Set((list || []).map((n) => String(Number(n))));
      camsRow.querySelectorAll(".cam-btn").forEach((el) => {
        if (want.has(el.dataset.cam)) el.classList.add("active");
        else el.classList.remove("active");
      });
    }

    function updateUrl() {
      const params = new URLSearchParams();
      if (experimentSel.value) params.set("experiment", experimentSel.value);
      if (treatmentSel.value) params.set("treatment", treatmentSel.value);
      const b = (batchInput.value || "").trim();
      if (b) params.set("batch", b);
      if (startDate.value) params.set("start_date", startDate.value);
      if (endDate.value) params.set("end_date", endDate.value);
      if (startTime.value) params.set("start_time", startTime.value);
      if (endTime.value) params.set("end_time", endTime.value);
      const cams = getSelectedCameras();
      if (cams.length) params.set("cameras", cams.join(","));
      const qs = params.toString();
      const url = qs ? `${location.pathname}?${qs}` : location.pathname;
      window.history.replaceState({}, "", url);
    }

    function ensureDefaultDates() {
      const today = new Date();
      const start = new Date(today);
      start.setDate(today.getDate() - 4);
      if (!endDate.value) endDate.value = formatDate(today);
      if (!startDate.value) startDate.value = formatDate(start);
    }

    async function initFromUrl() {
      const params = new URLSearchParams(location.search);
      const fac =
        params.get("facility") || (facilitySel && facilitySel.value) || "";
      const exp = (params.get("experiment") || "").toUpperCase();
      const trt = (params.get("treatment") || "").toLowerCase();
      const b = params.get("batch") || "";
      const sd = params.get("start_date") || "";
      const ed = params.get("end_date") || "";
      const st = params.get("start_time") || "";
      const et = params.get("end_time") || "";
      const camParam = (params.get("cameras") || "").trim();
      const camList = camParam
        ? camParam
          .split(",")
          .map((s) => parseInt(s, 10))
          .filter((n) => Number.isFinite(n))
        : [];

      if (sd) startDate.value = sd;
      if (ed) endDate.value = ed;
      if (st) startTime.value = st;
      if (et) endTime.value = et;
      ensureDefaultDates();

      if (fac && FACS[fac]) {
        facilitySel.value = fac;
        facilitySel.dispatchEvent(new Event("change"));
        if (exp) {
          experimentSel.value = exp;
          experimentSel.dispatchEvent(new Event("change"));
        }
        if (trt) {
          treatmentSel.value = trt;
          treatmentSel.dispatchEvent(new Event("change"));
        }
        if (camList.length) {
          setSelectedCameras(camList);
        }
        if (b) {
          batchInput.value = String(Math.max(0, parseInt(b, 10) || 1));
        } else {
          await refreshBatch();
        }
        updateUrl();
        validate();
      } else {
        ensureDefaultDates();
        // If header already selected a facility, apply it now (without emitting 'change')
        if (facilitySel && facilitySel.value) {
          try {
            refreshFacility();
          } catch (e) { }
        }
        updateUrl();
      }
    }

    // React to global facility changes from header
    function refreshFacility() {
      try {
        const fac = facilitySel && facilitySel.value;
        if (!fac || !FACS[fac]) return;
        srcDir.value = combinedSourcePattern(fac);
        populateExperiments(fac);
        populateCameras(fac);
        const exps = Object.keys((FACS[fac] || {}).experiments || {}).sort();
        if (exps.length > 0) {
          experimentSel.value = exps[0];
          populateTreatments(fac, experimentSel.value);
          const trts =
            ((FACS[fac] || {}).experiments || {})[experimentSel.value] || [];
          if (trts.length > 0) {
            treatmentSel.value = trts[0];
            applyTreatmentDefaults(
              fac,
              experimentSel.value,
              treatmentSel.value
            );
          } else {
            startTime.value = "";
            endTime.value = "";
          }
        } else {
          experimentSel.value = "";
          treatmentSel.value = "";
          startTime.value = "";
          endTime.value = "";
        }
        validate();
        updateUrl();
      } catch (e) { }
    }
    document.addEventListener("app:facility-changed", function () {
      try {
        updateUrl();
        refreshFacility();
      } catch (e) { }
    });

    function setDisabled(el, dis) {
      el.disabled = !!dis;
      if (dis) el.value = "";
    }

    function populateFacilities() {
      if (!facilitySel) return;
      const cur = (facilitySel && facilitySel.value) || "";
      const keys = Object.keys(FACS).sort();
      // Rebuild options but preserve current selection if present
      const hasCur = cur && keys.indexOf(cur) !== -1;
      facilitySel.innerHTML = hasCur
        ? ""
        : '<option value="">Select facility…</option>';
      keys.forEach((k) => {
        const opt = document.createElement("option");
        opt.value = k;
        opt.textContent = k;
        facilitySel.appendChild(opt);
      });
      if (hasCur) {
        facilitySel.value = cur;
      }
    }

    function populateExperiments(fac) {
      experimentSel.innerHTML = "";
      setDisabled(experimentSel, true);
      setDisabled(treatmentSel, true);
      treatmentSel.innerHTML = "";
      if (!fac || !FACS[fac]) return;
      const exps = FACS[fac].experiments || {};
      const names = Object.keys(exps).sort();
      experimentSel.innerHTML = '<option value="">Select experiment…</option>';
      names.forEach((name) => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        experimentSel.appendChild(opt);
      });
      setDisabled(experimentSel, false);
      refreshBatch();
    }

    function populateTreatments(fac, exp) {
      treatmentSel.innerHTML = "";
      setDisabled(treatmentSel, true);
      if (!fac || !exp || !FACS[fac]) return;
      const arr = (FACS[fac].experiments || {})[exp] || [];
      treatmentSel.innerHTML = '<option value="">Select treatment…</option>';
      arr.forEach((t) => {
        const opt = document.createElement("option");
        opt.value = t;
        opt.textContent = t;
        treatmentSel.appendChild(opt);
      });
      setDisabled(treatmentSel, false);
    }

    function applyTreatmentDefaults(fac, exp, trt) {
      if (!fac || !exp || !trt) return;
      const defs =
        (((FACS[fac] || {}).treatment_defaults || {})[exp] || {})[trt] || {};
      if (defs.start_time) startTime.value = defs.start_time;
      if (defs.end_time) endTime.value = defs.end_time;
    }

    function populateCameras(fac) {
      camsRow.innerHTML = "";
      const list =
        FACS[fac] && Array.isArray(FACS[fac].camera_list)
          ? FACS[fac].camera_list
          : null;
      const n =
        list && list.length
          ? list.length
          : (FACS[fac] && Number(FACS[fac].cameras)) || 0;
      camsToolbar.hidden = !n;
      camsHint.textContent = n
        ? `Pick from ${n} camera(s).`
        : "Select a facility to load available cameras.";
      if (!n) return;

      const items =
        list && list.length
          ? list.slice()
          : Array.from({ length: n }, (_, i) => i + 1);
      items.forEach((camNum) => {
        const btn = document.createElement("div");
        btn.className = "cam-btn";
        btn.dataset.cam = String(camNum);
        btn.textContent = String(camNum);
        btn.addEventListener("click", () => {
          btn.classList.toggle("active");
          validate();
          updateUrl();
        });
        camsRow.appendChild(btn);
      });

      camsAllBtn.onclick = () => {
        camsRow
          .querySelectorAll(".cam-btn")
          .forEach((el) => el.classList.add("active"));
        validate();
        updateUrl();
      };
      camsNoneBtn.onclick = () => {
        camsRow
          .querySelectorAll(".cam-btn")
          .forEach((el) => el.classList.remove("active"));
        validate();
        updateUrl();
      };
    }

    function validate() {
      const hasFac = !!facilitySel.value;
      const hasExp = !!experimentSel.value;
      const hasTrt = !!treatmentSel.value;
      const hasDates = !!startDate.value && !!endDate.value;
      const hasTimes = !!startTime.value && !!endTime.value;
      const anyCam = !!camsRow.querySelector(".cam-btn.active");
      let scanActive = false;
      try { scanActive = !!window.__SCAN_JOB_ID__ || !!scanController; } catch { }
      let reason = "";
      if (!hasFac) reason = "Select a facility";
      else if (!hasExp || !hasTrt) reason = "Pick experiment and treatment";
      else if (!hasDates) reason = "Set start/end dates";
      else if (!hasTimes) reason = "Set start/end times";
      else if (!anyCam) reason = "Pick at least one camera";
      importBtn.disabled = !(
        hasFac &&
        hasExp &&
        hasTrt &&
        hasDates &&
        hasTimes &&
        anyCam
      );
      if (listImportBtn) {
        listImportBtn.disabled = !(
          hasFac &&
          hasExp &&
          hasTrt &&
          hasDates &&
          hasTimes &&
          anyCam
        ) || scanActive;
        listImportBtn.title = listImportBtn.disabled
          ? reason || "Complete selections to list files"
          : "List files that match your selection";
      }
      // Scan tooltip
      importBtn.title = importBtn.disabled
        ? reason || "Complete selections to enable scan"
        : "";
      // If no plan yet, keep Run disabled with tooltip
      if (
        runTopBtn &&
        (!window.__DAYS_PLAN__ ||
          !Array.isArray(window.__DAYS_PLAN__) ||
          window.__DAYS_PLAN__.length === 0)
      ) {
        runTopBtn.disabled = true;
        runTopBtn.classList.remove("primary");
        runTopBtn.title = "Run is available after a successful scan";
      }
    }

    facilitySel.addEventListener("change", () => {
      const fac = facilitySel.value;
      srcDir.value = combinedSourcePattern(fac);
      populateExperiments(fac);
      populateCameras(fac);
      // Preselect first experiment and treatment (if available) and apply defaults
      const exps = Object.keys((FACS[fac] || {}).experiments || {}).sort();
      if (exps.length > 0) {
        experimentSel.value = exps[0];
        populateTreatments(fac, experimentSel.value);
        const trts =
          ((FACS[fac] || {}).experiments || {})[experimentSel.value] || [];
        if (trts.length > 0) {
          treatmentSel.value = trts[0];
          applyTreatmentDefaults(fac, experimentSel.value, treatmentSel.value);
        } else {
          // no treatments; clear times
          startTime.value = "";
          endTime.value = "";
        }
      } else {
        // no experiments; clear times
        startTime.value = "";
        endTime.value = "";
      }
      refreshBatch();
      validate();
      updateUrl();
    });
    experimentSel.addEventListener("change", () => {
      populateTreatments(facilitySel.value, experimentSel.value);
      // clear times when experiment changes; treatment selection will set defaults
      startTime.value = "";
      endTime.value = "";
      refreshBatch();
      validate();
      updateUrl();
    });
    treatmentSel.addEventListener("change", () => {
      applyTreatmentDefaults(
        facilitySel.value,
        experimentSel.value,
        treatmentSel.value
      );
      refreshBatch();
      validate();
      updateUrl();
    });
    startDate.addEventListener("change", () => {
      validate();
      updateUrl();
    });
    endDate.addEventListener("change", () => {
      validate();
      updateUrl();
    });
    startTime.addEventListener("change", () => {
      validate();
      updateUrl();
    });
    endTime.addEventListener("change", () => {
      validate();
      updateUrl();
    });

    // reset button removed

    // removed Scan button and handler

    // List button: stream full scan with date/time for in-range and day assignment
    if (listBtn) {
      listBtn.addEventListener("click", async () => {
        hideErrorBanner();
        const fac = facilitySel.value;
        if (!fac) { alert("Please select a facility first."); return; }
        setScanMode("list");
        setListBtnState("running");
        setListImportBtnState("disabled");
        try {
          const chk = await fetch(`/api/import/check_source?facility=${encodeURIComponent(fac)}`);
          if (!chk.ok) {
            const d = await chk.json().catch(() => ({}));
            throw new Error((d && d.error) || "Source folder not accessible");
          }
          // Use background scan/prepare job but do not auto-run encode
          await startScanAndRun(false, "list");
        } catch (e) {
          showError("List error", e);
          stopScanProgress();
          setListBtnState("idle");
          setListImportBtnState("idle");
        }
      });
    }

    if (listImportBtn) {
      listImportBtn.addEventListener("click", async () => {
        hideErrorBanner();
        const fac = facilitySel.value;
        const exp = experimentSel.value;
        const trt = treatmentSel.value;
        const sDate = startDate.value;
        const eDate = endDate.value;
        const sTime = startTime.value;
        const eTime = endTime.value;
        const cams = getSelectedCameras();
        if (!fac || !exp || !trt || !sDate || !eDate || !sTime || !eTime || cams.length === 0) {
          showError("List", new Error("Complete selections first."));
          return;
        }
        setScanMode("list-filtered");
        setListImportBtnState("running");
        setListBtnState("disabled");
        try {
          const chk = await fetch(`/api/import/check_source?facility=${encodeURIComponent(fac)}`);
          if (!chk.ok) {
            const d = await chk.json().catch(() => ({}));
            throw new Error((d && d.error) || "Source folder not accessible");
          }
          await startScanAndRun(false, "list-filtered");
        } catch (e) {
          showError("List error", e);
          stopScanProgress();
          setListImportBtnState("idle");
          setListBtnState("idle");
        }
      });
    }

    // Import button: stream scan then prepare per-day lists
    async function onStartScan() {
      hideErrorBanner();
      const fac = facilitySel.value;
      const exp = experimentSel.value;
      const trt = treatmentSel.value;
      const sDate = startDate.value;
      const eDate = endDate.value;
      const sTime = startTime.value;
      const eTime = endTime.value;
      const cams = getSelectedCameras();
      const batch = Math.max(0, Number(batchInput.value || 0));
      if (
        !fac ||
        !exp ||
        !trt ||
        !sDate ||
        !eDate ||
        !sTime ||
        !eTime ||
        cams.length === 0
      ) {
        alert(
          "Please complete selections (facility/experiment/treatment/dates/times/cameras)."
        );
        return;
      }
      setScanMode("import");
      setListBtnState("disabled");
      setListImportBtnState("disabled");
      const trigBtn = document.getElementById('import-btn') || document.getElementById('open-import');
      if (trigBtn) { trigBtn.disabled = true; trigBtn.textContent = "Scanning…"; }
      try {
        const rb = document.getElementById("run-btn");
        if (rb) {
          rb.disabled = true;
          rb.classList.remove("primary");
          rb.title = "Run available after scan completes";
        }
      } catch { }
      try {
        const chk = await fetch(
          `/api/import/check_source?facility=${encodeURIComponent(fac)}`
        );
        if (!chk.ok) {
          const d = await chk.json().catch(() => ({}));
          throw new Error((d && d.error) || "Source folder not accessible");
        }
        ensureScanPanel();
        startScanProgress(
          `Import prep – scanning in ${combinedSourcePattern(fac)} …`,
          false
        );
        const pattern =
          (FACS[fac] && (FACS[fac].camera_pattern || FACS[fac].camera_glob)) ||
          "";
        const qs = new URLSearchParams({
          facility: fac,
          cameras: cams.join(","),
          camera_pattern: pattern,
          start_date: sDate,
          end_date: eDate,
          start_time: sTime,
          end_time: eTime,
        });
        const es = new EventSource(
          `/api/import/scan_full_stream?${qs.toString()}`
        );
        scanController = { close: () => es.close() };
        const files = [];
        es.addEventListener("camera", (ev) => {
          try {
            const d = JSON.parse(ev.data);
            if (d && d.camera) {
              setScanMeta(
                `Camera cam${String(d.camera).padStart(2, "0")} — ${d.root}${d.exists ? "" : " (missing)"
                }`
              );
              appendDirRow({
                camera: d.camera,
                path: d.root,
                header: true,
                exists: d.exists,
              });
            }
          } catch { }
        });
        es.addEventListener("dir", (ev) => {
          try {
            const d = JSON.parse(ev.data);
            if (d && d.path) {
              const run = document.getElementById("scan-running-meta");
              if (run) run.textContent = `Scanning: ${d.path}`;
              appendDirRow(d);
            }
          } catch { }
        });
        es.addEventListener("file", (ev) => {
          try {
            const d = JSON.parse(ev.data);
            if (d && d.path) {
              files.push(d);
              appendScanRow(d);
            }
          } catch { }
        });
        es.addEventListener("done", async () => {
          try {
            es.close();
            stopScanProgress();
            scanController = null;
            try { setListBtnState("idle"); } catch { }
            try { setListImportBtnState("idle"); } catch { }
            try { clearScanMode(); } catch { }
            // Update collapsed header with total files found
            try {
              setScanHeaderMeta(formatCount(files.length));
            } catch { }
            ensureDaysPanel();
            const res = await fetch("/api/import/prepare_from_manifest", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                facility: fac,
                experiment: exp,
                treatment: trt,
                batch,
                start_date: sDate,
                end_date: eDate,
                start_time: sTime,
                end_time: eTime,
                cameras: cams,
                files,
              }),
            });
            const data = await res.json();
            if (!res.ok || !data || data.error) {
              throw new Error((data && data.error) || res.statusText);
            }
            renderDaysPlan(data);
            // Start encoding automatically after preparing the plan
            await onRunEncode();
            // Bring Day Preparation into focus
            try {
              const dp = document.getElementById("days-status");
              if (dp) dp.scrollIntoView({ behavior: "smooth", block: "start" });
            } catch { }
          } catch (e) {
            showError("Prepare error", e);
            expandScanPanelOnError(String((e && e.message) || e || ""));
          } finally {
            if (trigBtn) {
              try {
                if (isEncoding && isEncoding()) {
                  trigBtn.disabled = false;
                  trigBtn.textContent = 'Cancel';
                  trigBtn.style.background = '#b71c1c';
                  trigBtn.style.color = '#fff';
                  trigBtn.dataset.running = '1';
                } else {
                  trigBtn.disabled = false;
                  trigBtn.textContent = 'Rescan';
                  trigBtn.style.background = '';
                  trigBtn.style.color = '';
                  trigBtn.dataset.running = '0';
                }
              } catch (e) { }
            }
            try { validate(); } catch { }
          }
        });
        es.onerror = () => {
          es.close();
          stopScanDots();
          stopScanProgress();
          scanController = null;
          if (trigBtn) { trigBtn.disabled = false; trigBtn.textContent = "Rescan"; }
          try { setListBtnState("idle"); } catch { }
          try { setListImportBtnState("idle"); } catch { }
          try { clearScanMode(); } catch { }
          try { validate(); } catch { }
          expandScanPanelOnError("Scan error");
        };
      } catch (e) {
        showError("Scan error", e);
        expandScanPanelOnError(String((e && e.message) || e || ""));
        if (trigBtn) { trigBtn.disabled = false; trigBtn.textContent = "Rescan"; }
        try { setListBtnState("idle"); } catch { }
        try { setListImportBtnState("idle"); } catch { }
        try { clearScanMode(); } catch { }
        try { validate(); } catch { }
      }
    }
    if (importBtn) importBtn.addEventListener("click", onStartScan);
    function setImportBtnStateRunning(running) {
      try {
        const btn = document.getElementById('open-import');
        if (!btn) return;
        if (running) {
          btn.disabled = false;
          btn.textContent = 'Cancel';
          btn.style.background = '#b71c1c';
          btn.style.color = '#fff';
          btn.dataset.running = '1';
        } else {
          btn.disabled = false;
          btn.textContent = 'Import';
          btn.style.background = '';
          btn.style.color = '';
          btn.dataset.running = '0';
        }
      } catch (e) { }
    }

    function isEncoding() { try { return !!window.__ENCODE_JOB_ID__; } catch { return false; } }

    let scanPollTimer = null;
    function stopScanPolling() { if (scanPollTimer) { clearInterval(scanPollTimer); scanPollTimer = null; } }
    async function pollScanStatus(jobId) {
      try {
        const r = await fetch(`/api/import/scan_prepare/status?job=${encodeURIComponent(jobId)}`);
        const d = await r.json();
        if (!r.ok || d.error) { throw new Error(d && d.error || r.statusText); }
        const status = String(d.status || "").toUpperCase();
        // Update Available Files table
        ensureScanPanel();
        try { renderScanResults({ total: d.total || 0, files: d.files || [] }); } catch { }
        try {
          const total = Number(d.total || 0);
          const shown = scanSeenPaths.size || 0;
          if (status === "RUNNING" || status === "QUEUED") {
            if (total > 0) {
              if (scanFilterInRange) {
                setScanMeta(`Found ${total.toLocaleString()} file(s) • in range ${shown.toLocaleString()}`);
              } else {
                setScanMeta(`Found ${total.toLocaleString()} file(s)${shown ? ` • showing ${shown.toLocaleString()}` : ""}`);
              }
            } else {
              setScanMeta("Scanning…");
            }
          }
        } catch { }
        // If plan present, render Day Preparation
        if (d.plan && d.plan.plan) { try { renderDaysPlan(d.plan); } catch { } }
        // Handle terminal states
        if (status === "DONE") {
          // Scan finished: stop progress and polling
          stopScanPolling();
          try {
            stopScanProgress();
            const total = Number(d.total || 0) || 0;
            const shown = scanSeenPaths.size || 0;
            const headerTotal = scanFilterInRange ? shown : (total || shown);
            const headerTxt = scanFilterInRange
              ? `${formatCount(headerTotal)} in range`
              : formatCount(headerTotal);
            setScanHeaderMeta(headerTxt);
            if (scanFilterInRange) {
              setScanMeta(shown ? `Scan complete. ${shown.toLocaleString()} file(s) in range.` : "Scan complete. No files in range.");
            } else {
              const finalCount = total || shown;
              setScanMeta(finalCount ? `Scan complete. Found ${finalCount.toLocaleString()} file(s).` : "Scan complete. No files found.");
            }
            if (scanFilterInRange ? shown === 0 : (total === 0 && shown === 0)) {
              const empty = document.querySelector("#scan-empty td");
              if (empty) empty.textContent = scanFilterInRange ? "No files in range." : "No files found.";
            }
          } catch { }
          // Auto start encode when plan is ready
          if (scanAutoRun) {
            try { setImportBtnStateIdle(); } catch { }
            try { await onRunEncode(); } catch { }
          } else {
            if (!isEncoding()) { try { setImportBtnStateIdle(); } catch { } }
          }
          try { setListBtnState("idle"); } catch { }
          try { setListImportBtnState("idle"); } catch { }
          try { validate(); } catch { }
          try { clearScanMode(); } catch { }
          try { localStorage.removeItem('cheesepie.scan_job'); } catch { }
          try { window.__SCAN_JOB_ID__ = null; } catch { }
        } else if (status === "CANCELLED" || status === "ERROR" || status === "FAILED") {
          stopScanPolling();
          setScanMeta(status === "CANCELLED" ? "Scan canceled." : "Scan error.");
          stopScanProgress();
          try { setListBtnState("idle"); } catch { }
          try { setListImportBtnState("idle"); } catch { }
          try { validate(); } catch { }
          if (!isEncoding()) { try { setImportBtnStateIdle(); } catch { } }
          try { clearScanMode(); } catch { }
          try { localStorage.removeItem('cheesepie.scan_job'); } catch { }
          try { window.__SCAN_JOB_ID__ = null; } catch { }
        }
      } catch (e) {
        stopScanPolling();
        try { stopScanProgress(); } catch { }
        try { setListBtnState("idle"); } catch { }
        try { setListImportBtnState("idle"); } catch { }
        try { validate(); } catch { }
        if (!isEncoding()) { try { setImportBtnStateIdle(); } catch { } }
        try { clearScanMode(); } catch { }
        try { showError('Scan status', e); } catch { }
      }
    }
    async function startScanAndRun(autoRun = true, modeOverride) {
      if (modeOverride) {
        setScanMode(modeOverride);
      } else {
        setScanMode(autoRun ? "import" : "list");
      }
      ensureScanPanel(); ensureDaysPanel();
      if (scanMode === "list") {
        setListBtnState("running");
        setListImportBtnState("disabled");
      } else if (scanMode === "list-filtered") {
        setListImportBtnState("running");
        setListBtnState("disabled");
      } else {
        setListBtnState("disabled");
        setListImportBtnState("disabled");
      }
      // Kick background Scan/Prepare job
      const fac = facilitySel.value;
      const exp = experimentSel.value;
      const trt = treatmentSel.value;
      const sDate = startDate.value;
      const eDate = endDate.value;
      const sTime = startTime.value;
      const eTime = endTime.value;
      const cams = getSelectedCameras();
      const batch = Math.max(0, Number(batchInput.value || 0));
      // Show progress UI
      let msgBase = "Import prep – scanning in";
      if (scanMode === "list-filtered") msgBase = "Listing in-range files in";
      else if (scanMode === "list") msgBase = "Full scan in";
      startScanProgress(`${msgBase} ${combinedSourcePattern(fac)} …`, true);
      try {
        const res = await fetch('/api/import/scan_prepare/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ facility: fac, experiment: exp, treatment: trt, batch, start_date: sDate, end_date: eDate, start_time: sTime, end_time: eTime, cameras: cams, camera_pattern: (FACS[fac] && (FACS[fac].camera_pattern || FACS[fac].camera_glob)) || '' }) });
        const d = await res.json();
        if (!res.ok || !d || d.error || !d.job_id) { throw new Error((d && d.error) || res.statusText); }
        window.__SCAN_JOB_ID__ = d.job_id;
        try { localStorage.setItem('cheesepie.scan_job', d.job_id); } catch { }
        stopScanPolling();
        scanPollTimer = setInterval(() => { pollScanStatus(d.job_id); }, 1000);
        try { await pollScanStatus(d.job_id); } catch { }
      } catch (e) {
        stopScanProgress();
        try { showError('Scan start', e); } catch { }
        // Reset Import button state
        try { setImportBtnStateIdle(); } catch { }
        try { setListBtnState("idle"); } catch { }
        try { setListImportBtnState("idle"); } catch { }
        try { clearScanMode(); } catch { }
      }
    }

    if (openImportBtn) openImportBtn.addEventListener('click', async () => {
      try {
        hideErrorBanner();
        ensureScanPanel(); ensureDaysPanel();
        // If encoding is running → cancel encode
        try {
          const ejid = (window.__ENCODE_JOB_ID__ || localStorage.getItem('cheesepie.encode_job') || '').trim();
          if (ejid) { await onStopEncode(); setImportBtnStateRunning(false); return; }
        } catch { }
        // If scan is running, direct user to the Scan panel cancel
        try {
          const sjid = (window.__SCAN_JOB_ID__ || localStorage.getItem('cheesepie.scan_job') || '').trim();
          if (sjid) {
            setScanPanelCollapsed(false, true);
            setScanMeta("Scan already running. Use Cancel in Available Files.");
            return;
          }
        } catch { }
        // Otherwise, start scan+prepare
        const ready = !!(facilitySel && facilitySel.value) && !!experimentSel.value && !!treatmentSel.value && !!startDate.value && !!endDate.value && !!startTime.value && !!endTime.value && getSelectedCameras().length > 0;
        validate();
        if (!ready) { showError('Import', new Error('Complete selections first.')); return; }
        setScanMode("import");
        setListBtnState("disabled");
        setListImportBtnState("disabled");
        setImportBtnStateScanning();
        await startScanAndRun();
      } catch (e) { try { showError('Import start error', e); } catch { } }
    });

    // Kick resume once UI is ready
    resumeJobs();

    // Day Preparation panel
    function ensureDaysPanel() {
      let panel = document.getElementById("days-status");
      if (!panel) {
        panel = document.createElement("div");
        panel.id = "days-status";
        panel.className = "panel";
        panel.style.marginTop = "16px";
        // Hidden by default; shown when there are rows in days-table
        panel.style.display = "none";
        panel.innerHTML = `
        <div class=\"panel-header\" style=\"display:flex; align-items:center; justify-content:space-between; padding:8px 16px;\">\n          <h1>Day Preparation</h1>\n          <div style=\"display:flex; gap:8px; align-items:center\">\n            <button class=\"btn\" id=\"stop-btn\" disabled>Stop</button>\n          </div>\n        </div>
        <div class="table-wrap">
          <div id="encode-progress" style="display:none; margin:8px 0">
            <div id="encode-text" class="muted">Idle</div>
            <div class="progress"><div id="encode-bar" class="bar" style="width:0%"></div></div>
          </div>
          <table id="days-table" style="width:100%; border-collapse:collapse; font-size:13px">
            <thead>
              <tr>
                <th style="text-align:left; padding:6px 4px">Camera</th>
                <th style="text-align:left; padding:6px 4px">Day</th>
                <th style="text-align:left; padding:6px 4px">Segs</th>
                <th style="text-align:left; padding:6px 4px">Path</th>
                <th style="text-align:left; padding:6px 4px">Duration</th>
                <th style="text-align:left; padding:6px 4px">Status</th>
                <th style="text-align:left; padding:6px 4px">Health</th>
              </tr>
            </thead>
            <tbody id="days-body"></tbody>
          </table>
        </div>`;
        const ctrl = document.querySelector(".panel .controls");
        if (ctrl && ctrl.parentElement) {
          ctrl.parentElement.insertAdjacentElement("afterend", panel);
        }
        // Run button is placed next to Scan at the top
        const stopBtn = document.getElementById("stop-btn");
        if (stopBtn) {
          // Hide legacy Stop button; Run button toggles to Stop in dialog header
          stopBtn.style.display = "none";
        }
        // Details/Retry controls removed
      }
    }

    // Simple status panel under the form
    function ensureStatusPanel() {
      let panel = document.getElementById("import-status");
      if (!panel) {
        panel = document.createElement("div");
        panel.id = "import-status";
        panel.className = "panel";
        panel.style.marginTop = "16px";
        panel.innerHTML = `
        <div class="panel-header"><h1>Import Status</h1></div>
        <div class="table-wrap">
          <div style="margin: 8px 0">
            <div id="overall-text" class="muted">Queued…</div>
            <div class="progress"><div id="overall-bar" class="bar" style="width:0%"></div></div>
          </div>
          <table id="status-table" style="width:100%; border-collapse:collapse; font-size:13px">
            <thead>
              <tr><th style="text-align:left; padding:6px 4px">Camera</th><th style="text-align:left; padding:6px 4px">Day</th><th style="text-align:left; padding:6px 4px">Segments</th><th style="text-align:left; padding:6px 4px">Status</th></tr>
            </thead>
            <tbody id="status-body"></tbody>
          </table>
        </div>`;
        document.querySelector(".panel .controls").after(panel);
        try {
          const hdr = panel.querySelector(".panel-header");
          if (hdr) {
            hdr.style.padding = "8px 12px";
            hdr.style.alignItems = "center";
          }
        } catch { }
      }
    }

    // Scan results panel under the form
    function ensureScanPanel() {
      let panel = document.getElementById("import-scan");
      if (!panel) {
        panel = document.createElement("div");
        panel.id = "import-scan";
        panel.className = "panel";
        panel.style.margin = "16px 8px";
        panel.innerHTML = `
        <div class=\"panel-header\" style=\"display:flex; align-items:center; justify-content:space-between; padding:8px 16px;\">
          <h1 id=\"scan-header\" style=\"cursor:pointer; margin:0; display:flex; align-items:center; gap:8px\">Available Files <span id=\"scan-header-meta\" class=\"muted\" style=\"font-size:12px\"></span></h1>
          <div style=\"display:flex; align-items:center\"><button type=\"button\" id=\"scan-toggle-btn\" class=\"btn mini\">Show</button></div>
        </div>
        <div id=\"scan-content\" class=\"table-wrap\" style=\"display:none; padding:8px 12px\">
          <div id="scan-progress" style="display:none; margin: 8px 0; align-items:center; gap:12px">
            <div style="flex:1">
              <div id="scan-running-meta" class="muted" style="margin-bottom:6px"></div>
              <div class="progress"><div id="scan-bar" class="bar" style="width:0%"></div></div>
            </div>
            <button type="button" id="scan-cancel" class="btn" style="white-space:nowrap">Cancel</button>
          </div>
          <div id="scan-meta" class="muted" style="margin: 8px 0"></div>
          <div id="scan-list" style="max-height: 320px; overflow:auto;"></div>
        </div>`;
        document.querySelector(".panel .controls").after(panel);
        // Setup collapse/expand toggle
        const scanToggleBtn = document.getElementById("scan-toggle-btn");
        const scanHeader = document.getElementById("scan-header");
        const scanContent = document.getElementById("scan-content");
        function setScanCollapsed(collapsed) {
          if (!scanContent || !scanToggleBtn) return;
          scanContent.style.display = collapsed ? "none" : "block";
          scanToggleBtn.textContent = collapsed ? "Show" : "Hide";
          panel.dataset.collapsed = collapsed ? "1" : "0";
        }
        panel.setAttribute("data-collapsed", "1");
        setScanCollapsed(true);
        function toggleCollapsed() {
          const isCollapsed = panel.dataset.collapsed !== "0";
          setScanCollapsed(!isCollapsed);
        }
        if (scanToggleBtn)
          scanToggleBtn.addEventListener("click", toggleCollapsed);
        if (scanHeader) scanHeader.addEventListener("click", toggleCollapsed);
        const cancelBtn = document.getElementById("scan-cancel");
        cancelBtn.addEventListener("click", async () => {
          try { if (scanPollTimer) { clearInterval(scanPollTimer); scanPollTimer = null; } } catch { }
          try {
            const jid = (window.__SCAN_JOB_ID__ || '').trim();
            if (jid) { await fetch(`/api/import/scan_prepare/cancel?job=${encodeURIComponent(jid)}`, { method: 'POST' }); }
          } catch { }
          scanController = null;
          stopScanProgress();
          setScanMeta("Scan canceled.");
          try { localStorage.removeItem('cheesepie.scan_job'); } catch { }
          try { window.__SCAN_JOB_ID__ = null; } catch { }
          try { clearScanMode(); } catch { }
          try { setListBtnState("idle"); } catch { }
          try { setListImportBtnState("idle"); } catch { }
          if (!isEncoding()) { try { setImportBtnStateIdle(); } catch { } }
        });
      }
    }

    function setScanMeta(text) {
      const meta = document.getElementById("scan-meta");
      if (meta) meta.textContent = text || "";
    }

    function setScanHeaderMeta(text) {
      const m = document.getElementById("scan-header-meta");
      if (m) m.textContent = text || "";
    }

    function startScanDots(base) {
      try {
        stopScanDots();
      } catch { }
      scanDotsBase = (base && String(base)) || "Scanning";
      let i = 0;
      setScanHeaderMeta(scanDotsBase);
      scanDotsTimer = setInterval(() => {
        i = (i + 1) % 4;
        setScanHeaderMeta(scanDotsBase + ".".repeat(i));
      }, 400);
    }

    function stopScanDots() {
      if (scanDotsTimer) {
        clearInterval(scanDotsTimer);
        scanDotsTimer = null;
      }
    }

    function formatCount(n) {
      try {
        const v = Number(n || 0);
        return `${v.toLocaleString()} file(s)`;
      } catch {
        return `${n} file(s)`;
      }
    }

    function isScanPanelCollapsed() {
      const panel = document.getElementById("import-scan");
      if (!panel) return true;
      return panel.dataset.collapsed !== "0";
    }

    function setScanPanelCollapsed(collapsed, scrollIntoView) {
      try {
        const panel = document.getElementById("import-scan");
        const content = document.getElementById("scan-content");
        const btn = document.getElementById("scan-toggle-btn");
        if (panel && content && btn) {
          const wantCollapsed = !!collapsed;
          content.style.display = wantCollapsed ? "none" : "block";
          btn.textContent = wantCollapsed ? "Show" : "Hide";
          panel.dataset.collapsed = wantCollapsed ? "1" : "0";
          if (!wantCollapsed && scrollIntoView) {
            panel.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        }
      } catch { }
    }

    function resetScanTable() {
      scanSeenPaths = new Set();
      const wrap = document.getElementById("scan-list");
      if (!wrap) return;
      wrap.innerHTML = `
        <table id="scan-table" style="width:100%; border-collapse:collapse; font-size:13px">
          <thead>
            <tr>
              <th style="text-align:left">Camera</th>
              <th style="text-align:left">Date</th>
              <th style="text-align:left">Start</th>
              <th style="text-align:left">Filename</th>
            </tr>
          </thead>
          <tbody id="scan-tbody"></tbody>
        </table>`;
      const tbody = document.getElementById("scan-tbody");
      if (tbody) {
        const empty = document.createElement("tr");
        empty.id = "scan-empty";
        empty.className = "scan-empty";
        const msg = scanFilterInRange ? "Waiting for files in range…" : "Waiting for files…";
        empty.innerHTML = `<td colspan="4" class="muted" style="padding:8px">${msg}</td>`;
        tbody.appendChild(empty);
      }
    }

    function ensureScanTable() {
      const tbody = document.getElementById("scan-tbody");
      if (!tbody) resetScanTable();
    }

    function clearScanPlaceholder() {
      const empty = document.getElementById("scan-empty");
      if (empty && empty.parentElement) empty.parentElement.removeChild(empty);
    }

    function startScanProgress(message, expand) {
      const box = document.getElementById("scan-progress");
      const bar = document.getElementById("scan-bar");
      const running = document.getElementById("scan-running-meta");
      try {
        const panel = document.getElementById("import-scan");
        const content = document.getElementById("scan-content");
        const btn = document.getElementById("scan-toggle-btn");
        if (panel && content && btn) {
          const wantExpand = !!expand;
          content.style.display = wantExpand ? "block" : "none";
          btn.textContent = wantExpand ? "Hide" : "Show";
          panel.dataset.collapsed = wantExpand ? "0" : "1";
        }
      } catch { }
      startScanDots(scanMode === "import" ? "Scanning" : "Listing");
      if (box) {
        box.style.display = "flex";
      }
      if (running) {
        running.textContent = message || "Scanning…";
      }
      setScanMeta("");
      resetScanTable();
      if (bar) {
        let pct = 5;
        if (scanAnimTimer) clearInterval(scanAnimTimer);
        scanAnimTimer = setInterval(() => {
          pct = (pct + 7) % 100;
          bar.style.width = pct + 10 + "%";
        }, 120);
      }
    }

    function stopScanProgress() {
      const box = document.getElementById("scan-progress");
      if (box) {
        box.style.display = "none";
      }
      stopScanDots();
      setScanHeaderMeta("");
      if (scanAnimTimer) {
        clearInterval(scanAnimTimer);
        scanAnimTimer = null;
      }
      const bar = document.getElementById("scan-bar");
      if (bar) {
        bar.style.width = "0%";
      }
    }

    function expandScanPanelOnError(message) {
      try {
        const panel = document.getElementById("import-scan");
        const content = document.getElementById("scan-content");
        const btn = document.getElementById("scan-toggle-btn");
        const meta = document.getElementById("scan-meta");
        if (panel && content && btn) {
          content.style.display = "block";
          btn.textContent = "Hide";
          panel.dataset.collapsed = "0";
        }
        setScanHeaderMeta("Error");
        if (meta && message) meta.textContent = message;
      } catch { }
    }

    function renderScanResults(data) {
      ensureScanTable();
      const files = Array.isArray(data.files) ? data.files : [];
      if (!files.length && scanSeenPaths.size === 0) return;
      updateScanRows(files);
    }

    function updateScanRows(files) {
      if (!Array.isArray(files)) return;
      for (const f of files) {
        const key = (f && f.path) ? String(f.path) : "";
        if (!key || scanSeenPaths.has(key)) continue;
        if (scanFilterInRange && !f.in_range) continue;
        scanSeenPaths.add(key);
        appendScanRow(f);
      }
    }

    function appendScanRow(f) {
      const tbody = document.getElementById("scan-tbody");
      if (!tbody) return;
      clearScanPlaceholder();
      if (f && f.path) {
        try { scanSeenPaths.add(String(f.path)); } catch { }
      }
      const camStr = f.camera != null ? String(f.camera).padStart(2, "0") : "—";
      const startTxt = (f.start || '').replace('T', ' ');
      const parts = startTxt.split(' ');
      const dateStr = parts[0] || "—";
      const startStr = f.start_hms || parts[1] || "—";
      const tr = document.createElement("tr");
      if (f.in_range) tr.classList.add("scan-in-range");
      const tdCam = document.createElement("td");
      tdCam.textContent = camStr;
      const tdDate = document.createElement("td");
      tdDate.textContent = dateStr;
      const tdStart = document.createElement("td");
      tdStart.textContent = startStr;
      const tdPath = document.createElement("td");
      tdPath.className = "scan-path";
      tdPath.textContent = f.path || "";
      tdPath.title = f.path || "";
      tr.appendChild(tdCam);
      tr.appendChild(tdDate);
      tr.appendChild(tdStart);
      tr.appendChild(tdPath);
      tbody.appendChild(tr);
    }

    function renderPlan(data) {
      const body = document.getElementById("status-body");
      if (!body) return;
      const bar = document.getElementById("overall-bar");
      const txt = document.getElementById("overall-text");
      let rows = "";
      for (const cam of data.jobs) {
        for (const d of cam.days) {
          rows += `<tr>
          <td style="padding:6px 4px">cam${String(cam.camera).padStart(
            2,
            "0"
          )}</td>
          <td style="padding:6px 4px">${String(d.day).padStart(2, "0")}</td>
          <td style="padding:6px 4px">${d.segments || 0}</td>
          <td style="padding:6px 4px">${d.status || ""}</td>
        </tr>`;
        }
      }
      body.innerHTML =
        rows ||
        '<tr><td colspan="4" class="muted" style="padding:6px">No jobs.</td></tr>';
      if (
        typeof data.progress === "number" &&
        typeof data.total === "number" &&
        data.total > 0
      ) {
        const pct = Math.round((100 * data.progress) / data.total);
        bar.style.width = pct + "%";
        txt.textContent = `Progress: ${data.progress}/${data.total}`;
      }
    }

    async function pollStatus(jobId) {
      const url = `/api/import/status?job=${encodeURIComponent(jobId)}`;
      const timer = setInterval(async () => {
        try {
          const r = await fetch(url);
          const s = await r.json();
          if (!r.ok || !s || s.error) {
            throw new Error((s && s.error) || r.statusText);
          }
          const merged = Object.assign({}, s.plan, {
            progress: s.progress,
            total: s.total,
          });
          renderPlan(merged);
          if (s.status === "DONE") {
            clearInterval(timer);
          }
        } catch (e) {
          clearInterval(timer);
        }
      }, 2000);
    }

    // Initialize
    populateFacilities();
    initFromUrl();
    validate();
    if (runTopBtn)
      runTopBtn.addEventListener("click", () => {
        const rb = document.getElementById("run-btn");
        if (rb && rb.dataset && rb.dataset.running === "1") {
          onStopEncode();
        } else {
          onRunEncode();
        }
      });

    // Modal open/close
    const openImport = document.getElementById("open-import");
    const modal = document.getElementById("import-modal");
    const modalBody = document.getElementById("import-modal-body");
    const modalClose = document.getElementById("import-close");
    function __unused_openImportDialog() {
      try {
        ensureScanPanel();
        ensureDaysPanel();
        const scanPanel = document.getElementById("import-scan");
        const daysPanel = document.getElementById("days-status");
        if (scanPanel && modalBody && scanPanel.parentElement !== modalBody) {
          modalBody.appendChild(scanPanel);
        }
        if (daysPanel && modalBody && daysPanel.parentElement !== modalBody) {
          modalBody.appendChild(daysPanel);
        }
        modal.style.display = "flex";
        // Add Escape-to-close
        try {
          document.addEventListener("keydown", __unused_onImportKeydown);
        } catch { }
        // Auto-start scan if selections are complete (do not rely on stale disabled state)
        const ready =
          !!(facilitySel && facilitySel.value) &&
          !!experimentSel.value &&
          !!treatmentSel.value &&
          !!startDate.value &&
          !!endDate.value &&
          !!startTime.value &&
          !!endTime.value &&
          getSelectedCameras().length > 0;
        try {
          validate();
        } catch { }
        if (ready) {
          onStartScan();
        }
        // Otherwise, keep dialog open showing last scan (if any) and hint user to close and complete selections
      } catch (e) {
        try {
          showError("Open import dialog error", e);
        } catch { }
      }
    }
    function __unused_closeImportDialog() {
      if (modal) modal.style.display = "none";
      try {
        document.removeEventListener("keydown", __unused_onImportKeydown);
      } catch { }
    }
    // modal handler removed
    // modal handler removed
    // click outside panel closes dialog
    if (modal) {
      modal.addEventListener("click", (e) => {
        try {
          // modal removed
        } catch { }
      });
    }

    function __unused_onImportKeydown(e) {
      try {
        if (!modal || modal.style.display === "none") return;
        if (e.key === "Escape") {
          e.preventDefault();
          // modal removed
        }
      } catch { }
    }

    async function refreshBatch() {
      const exp = experimentSel.value;
      const trt = treatmentSel.value;
      if (!exp || !trt) {
        batchInput.value = "1";
        return;
      }
      try {
        const r = await fetch(
          `/api/import/next_batch?experiment=${encodeURIComponent(
            exp
          )}&treatment=${encodeURIComponent(trt)}`
        );
        const d = await r.json();
        if (r.ok && d && d.ok) {
          batchInput.value = d.next_batch;
        } else {
          batchInput.value = "1";
        }
      } catch {
        batchInput.value = "1";
      }
      updateUrl();
    }

    let encodeJobId = null;
    let encodeTimer = null;
    let currentRunPlan = null;
    async function onRunEncode() {
      const fac = facilitySel.value;
      const exp = experimentSel.value;
      const trt = treatmentSel.value;
      const batch = Math.max(0, Number(batchInput.value || 0));
      const plan = currentRunPlan || window.__DAYS_PLAN__ || [];
      const runBtn = document.getElementById("run-btn");
      const importBtnTop = document.getElementById('open-import');
      if (runBtn) {
        runBtn.disabled = true;
        runBtn.textContent = "Running…";
      }
      try {
        const progBox = document.getElementById("encode-progress");
        const progBar = document.getElementById("encode-bar");
        const progTxt = document.getElementById("encode-text");
        // Hide overall progress; we'll reflect progress in-row instead
        if (progBox) progBox.style.display = "none";
        if (progBar) progBar.style.width = "0%";
        if (progTxt) progTxt.textContent = "";
        const res = await fetch("/api/import/encode_days", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            facility: fac,
            experiment: exp,
            treatment: trt,
            batch,
            plan,
            start_date: startDate.value || "",
            end_date: endDate.value || "",
            start_time: startTime.value || "",
            end_time: endTime.value || "",
          }),
        });
        const data = await res.json();
        if (!res.ok || !data || data.error) {
          throw new Error((data && data.error) || res.statusText);
        }
        // If server returned a background job id, poll status.
        if (data.job_id) {
          encodeJobId = data.job_id;
          try {
            window.__ENCODE_JOB_ID__ = encodeJobId;
          } catch { }
          try { localStorage.setItem('cheesepie.encode_job', encodeJobId); } catch { }
          const rb = document.getElementById("run-btn");
          if (rb) {
            rb.disabled = false;
            rb.textContent = "Stop";
            rb.style.background = "#b71c1c";
            rb.style.color = "#fff";
            rb.title = "Cancel encoding";
            rb.dataset.running = "1";
          }
          if (importBtnTop) { importBtnTop.disabled = false; importBtnTop.textContent = 'Cancel'; importBtnTop.style.background = '#b71c1c'; importBtnTop.style.color = '#fff'; importBtnTop.dataset.running = '1'; }
          // Optimistically flag first runnable item as RUNNING
          try {
            const planArr = Array.isArray(window.__DAYS_PLAN__)
              ? window.__DAYS_PLAN__
              : [];
            let marked = false;
            for (const cam of planArr) {
              const days = Array.isArray(cam.days) ? cam.days : [];
              for (const d of days) {
                const st = String(d.status || "").toUpperCase();
                const segs =
                  typeof d.segments === "number"
                    ? d.segments
                    : st === "MISSING"
                      ? 0
                      : 1;
                if (
                  segs > 0 &&
                  st !== "DONE" &&
                  st !== "FAIL" &&
                  st !== "FAILED"
                ) {
                  d.status = "RUNNING";
                  marked = true;
                  break;
                }
              }
              if (marked) break;
            }
            if (marked) renderDaysPlan({ plan: planArr, status: "RUNNING" });
          } catch { }
          pollEncode();
        } else {
          // Fallback: render immediate plan (sync encode flow)
          if (data && data.plan) {
            try {
              renderDaysPlan(data);
            } catch (e) {
              // no-op; UI error surface elsewhere
            }
          }
          if (runBtn) {
            runBtn.disabled = false;
            runBtn.textContent = "Run";
          }
          if (importBtnTop) { importBtnTop.disabled = false; importBtnTop.textContent = "Import"; importBtnTop.style.background = ""; importBtnTop.style.color = ""; importBtnTop.dataset.running = "0"; }
        }
      } catch (e) {
        showError("Run error", e);
        if (runBtn) {
          runBtn.disabled = false;
          runBtn.textContent = "Run";
        }
        if (runBtn) runBtn.title = String((e && e.message) || "Error");
        // Reset Import button and clear any encode state
        try {
          const ib = document.getElementById('open-import');
          if (ib) { ib.disabled = false; ib.textContent = 'Import'; ib.style.background = ''; ib.style.color = ''; ib.dataset.running = '0'; }
        } catch { }
        try { window.__ENCODE_JOB_ID__ = null; } catch { }
        try { localStorage.removeItem('cheesepie.encode_job'); } catch { }
      }
    }

    async function pollEncode() {
      if (!encodeJobId) return;
      const runBtn = document.getElementById("run-btn");
      const importBtnTop = document.getElementById('open-import');
      encodeTimer = setInterval(async () => {
        try {
          const r = await fetch(
            `/api/import/encode_status?job=${encodeURIComponent(encodeJobId)}`
          );
          const s = await r.json();
          if (!r.ok || !s || s.error) {
            throw new Error((s && s.error) || r.statusText);
          }
          if (s && s.plan) {
            renderDaysPlan(s);
          }
          // While encoding is active, ensure Import button is in Cancel state
          try {
            const st = String(s.status || '').toUpperCase();
            const ib = document.getElementById('open-import');
            if (ib) {
              if (st === 'RUNNING' || st === 'QUEUED') {
                ib.disabled = false; ib.textContent = 'Cancel'; ib.style.background = '#b71c1c'; ib.style.color = '#fff'; ib.dataset.running = '1';
              }
            }
          } catch { }
          if (s.status === "DONE" || s.status === "CANCELLED") {
            clearInterval(encodeTimer);
            if (runBtn) {
              runBtn.disabled = false;
              runBtn.textContent = "Run";
              runBtn.style.background = "";
              runBtn.style.color = "";
              runBtn.dataset.running = "0";
              runBtn.title = "";
            }
            if (importBtnTop) { importBtnTop.disabled = false; importBtnTop.textContent = "Import"; importBtnTop.style.background = ""; importBtnTop.style.color = ""; importBtnTop.dataset.running = "0"; importBtnTop.title = ""; }
            currentRunPlan = null;
            try {
              window.__ENCODE_JOB_ID__ = null;
            } catch { }
            try { localStorage.removeItem('cheesepie.encode_job'); } catch { }
          }
        } catch (err) {
          clearInterval(encodeTimer);
          if (runBtn) {
            runBtn.disabled = false;
            runBtn.textContent = "Run";
            runBtn.style.background = "";
            runBtn.style.color = "";
            runBtn.dataset.running = "0";
            runBtn.title = "";
          }
          if (importBtnTop) { importBtnTop.disabled = false; importBtnTop.textContent = "Import"; importBtnTop.style.background = ""; importBtnTop.style.color = ""; importBtnTop.dataset.running = "0"; importBtnTop.title = ""; }
          try {
            window.__ENCODE_JOB_ID__ = null;
          } catch { }
          try { localStorage.removeItem('cheesepie.encode_job'); } catch { }
        }
      }, 2000);
    }

    async function onStopEncode() {
      if (!encodeJobId) return;
      const rb = document.getElementById("run-btn");
      if (rb) {
        rb.disabled = true;
        rb.textContent = "Stopping…";
        rb.style.background = "#b71c1c";
        rb.style.color = "#fff";
      }
      try {
        const r = await fetch(
          `/api/import/encode_cancel?job=${encodeURIComponent(encodeJobId)}`,
          { method: "POST" }
        );
        const s = await r.json();
        if (!r.ok || !s || s.error)
          throw new Error((s && s.error) || r.statusText);
      } catch (e) {
        showError("Cancel error", e);
        if (rb) {
          rb.disabled = false;
          rb.textContent = "Stop";
          rb.style.background = "#b71c1c";
          rb.style.color = "#fff";
          rb.title = "Cancel encoding";
        }
      }
    }

    // Retry-failed functionality removed

    //
  });

  // Renders the Day Preparation plan into the table and updates controls
  function renderDaysPlan(data) {
    try {
      // Ensure the panel exists
      (function ensure() {
        if (!document.getElementById("days-status")) {
          if (typeof ensureDaysPanel === "function") ensureDaysPanel();
        }
      })();
      const body = document.getElementById("days-body");
      const runBtn = document.getElementById("run-btn");
      if (!body) return;
      const plan = Array.isArray(data && data.plan) ? data.plan : [];
      window.__DAYS_PLAN__ = plan;

      let rows = "";
      let anyWait = false;
      for (const cam of plan) {
        const camStr =
          cam && cam.camera != null
            ? String(cam.camera).padStart(2, "0")
            : "??";
        const days = Array.isArray(cam && cam.days) ? cam.days : [];
        for (const d of days) {
          const dayStr =
            d && d.day != null ? String(d.day).padStart(2, "0") : "??";
          const statusRaw = String((d && d.status) || "");
          const status = statusRaw.toUpperCase();
          const segs =
            typeof d.segments === "number"
              ? d.segments
              : status === "MISSING"
                ? 0
                : 1;
          if (
            status === "WAITING" ||
            status === "PLANNED" ||
            status === "PENDING"
          )
            anyWait = anyWait || segs > 0;
          // Status with color badges
          let statusHtml = status;
          if (status === "RUNNING") {
            statusHtml = `<span style="background:#00A0B0;color:#D8F9FF;padding:2px 6px;border-radius:10px;font-weight:600">RUNNING</span>`;
          } else if (status === "DONE") {
            statusHtml = `<span style="background:#A2D15C;color:#335500;padding:2px 6px;border-radius:10px;font-weight:600">DONE</span>`;
          } else if (status === "FAIL" || status === "FAILED") {
            statusHtml = `<span style="background:#CC333F;color:#FFD6D9;padding:2px 6px;border-radius:10px;font-weight:600">FAILED</span>`;
          } else if (status === "CANCELLED") {
            statusHtml = `<span style="background:#CC333F;color:#FFD6D9;padding:2px 6px;border-radius:10px;font-weight:600">CANCELLED</span>`;
          } else if (status === "PENDING") {
            statusHtml = `<span style="background:#EDC951;color:#7A5F00;padding:2px 6px;border-radius:10px;font-weight:600">PENDING</span>`;
          } else if (status === "MISSING") {
            statusHtml = `<span style="background:#CC333F;color:#FFD6D9;padding:2px 6px;border-radius:10px;font-weight:600">MISSING</span>`;
          } else if (status === "WAITING" || status === "PLANNED") {
            statusHtml = `<span style="background:#A19381;color:#3F2D18;padding:2px 6px;border-radius:10px;font-weight:600">${status}</span>`;
          }
          // Duration cell
          let durTxt = "";
          const toHMS = (secs) => {
            if (typeof secs !== "number" || !isFinite(secs) || secs <= 0)
              return "";
            const s = Math.floor(secs);
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            const pad = (n) => String(n).padStart(2, "0");
            return h > 0 ? `${h}:${pad(m)}:${pad(sec)}` : `${m}:${pad(sec)}`;
          };
          if (d && d.duration != null) {
            durTxt = toHMS(Number(d.duration));
          } else if (d && d.health && typeof d.health.actual === "number") {
            durTxt = toHMS(Number(d.health.actual));
          }

          let healthTxt = "";
          if (d && d.health && typeof d.health === "object") {
            const ok = !!d.health.ok;
            healthTxt = ok
              ? `<span style=\"background:#A2D15C;color:#ffffff;padding:2px 6px;border-radius:10px;font-weight:600\">GOOD</span>`
              : `<span style=\"background:#CC333F;color:#ffffff;padding:2px 6px;border-radius:10px;font-weight:600\">POOR</span>`;
          }
          const path = (d && (d.output || d.list_path)) || "";
          rows += `<tr>
            <td style=\"padding:6px 4px\">${camStr}</td>
            <td style=\"padding:6px 4px\">${dayStr}</td>
            <td style=\"padding:6px 4px\">${segs}</td>
            <td style=\"padding:6px 4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis\">${(path && !/\.txt$/i.test(path)) ? `<a href=\"#\" class=\"dp-preview\" data-path=\"${encodeURIComponent(path)}\" title=\"Preview video\">${path}</a>` : (path || '')}</td>
            <td style=\"padding:6px 4px\">${durTxt}</td>
            <td style=\"padding:6px 4px\">${statusHtml}</td>
            <td style=\"padding:6px 4px\">${healthTxt}</td>
          </tr>`;
        }
      }
      // Update table body
      body.innerHTML = rows || '';
      // Toggle panel visibility based on presence of rows
      try {
        const panel = document.getElementById('days-status');
        if (panel) panel.style.display = rows ? '' : 'none';
      } catch { }

      // No separate overall progress UI; status is reflected per row

      // Enable/disable Run + Retry buttons
      if (runBtn) {
        const st = String((data && data.status) || "").toUpperCase();
        const jobId =
          typeof window !== "undefined" && window.__ENCODE_JOB_ID__
            ? window.__ENCODE_JOB_ID__
            : null;
        if (st === "RUNNING" || st === "QUEUED") {
          // If a job is active, allow stopping via the Run button
          if (jobId) {
            runBtn.disabled = false;
            runBtn.textContent = "Stop";
            runBtn.style.background = "#b71c1c";
            runBtn.style.color = "#fff";
            runBtn.dataset.running = "1";
            runBtn.classList.remove("primary");
            runBtn.title = "Cancel encoding";
          } else {
            runBtn.disabled = true;
            runBtn.textContent = st === "RUNNING" ? "Running…" : "Queued…";
            runBtn.classList.remove("primary");
            runBtn.title = "Encoding in progress";
          }
        } else {
          runBtn.disabled = !anyWait;
          runBtn.textContent = "Run";
          runBtn.style.background = "";
          runBtn.style.color = "";
          runBtn.dataset.running = "0";
          if (!anyWait) {
            runBtn.classList.remove("primary");
            runBtn.title = "No runnable days (pending segments)";
          } else {
            runBtn.classList.add("primary");
            runBtn.title = "";
          }
        }
      }
      // Retry failed button removed
    } catch (err) {
      try {
        showError("Render plan error", err);
      } catch { }
    }
  }

  // Lightweight video preview overlay for Day Preparation paths
  (function setupDayPreview() {
    function closeOverlay() {
      try { const ov = document.getElementById('dp-video-preview'); if (ov) ov.remove(); } catch (e) { }
      try { document.removeEventListener('keydown', onKey); } catch (e) { }
    }
    function onKey(ev) { if (ev.key === 'Escape') { ev.preventDefault(); closeOverlay(); } }
    function openPreview(path) {
      try {
        const decPath = decodeURIComponent(path || '');
        if (/\.txt$/i.test(decPath)) return; // ignore text lists
        // Build overlay
        const ov = document.createElement('div'); ov.id = 'dp-video-preview';
        ov.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:2000; display:flex; align-items:center; justify-content:center; padding:20px;';
        const panel = document.createElement('div');
        panel.style.cssText = 'background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:10px; box-shadow:0 10px 30px var(--shadow); width:min(1000px,96vw); max-width:96vw;';
        const header = document.createElement('div'); header.style.cssText = 'display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid var(--border,#ddd)';
        const title = document.createElement('div'); title.textContent = (decPath.split('/').pop() || decPath); title.style.cssText = 'font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;';
        const actions = document.createElement('div'); actions.style.cssText = 'display:flex; gap:8px; align-items:center';
        const analyze = document.createElement('a'); analyze.className = 'btn mini'; analyze.textContent = 'Open in Preview'; analyze.href = '/preview?video=' + encodeURIComponent(decPath);
        const close = document.createElement('button'); close.className = 'btn'; close.textContent = '✕'; close.title = 'Close'; close.style.cssText = 'font-weight:700; width:32px; height:32px; padding:0; display:inline-flex; align-items:center; justify-content:center';
        close.addEventListener('click', closeOverlay);
        actions.appendChild(analyze); actions.appendChild(close);
        header.appendChild(title); header.appendChild(actions);
        const body = document.createElement('div'); body.style.cssText = 'padding:8px 12px;';
        const video = document.createElement('video');
        video.controls = true; video.preload = 'metadata'; video.style.cssText = 'width:100%; height:auto; background:var(--surface);';
        const src = document.createElement('source'); src.src = '/media?path=' + encodeURIComponent(decPath);
        video.appendChild(src);
        body.appendChild(video);
        panel.appendChild(header); panel.appendChild(body); ov.appendChild(panel);
        ov.addEventListener('click', (e) => { if (e.target === ov) closeOverlay(); });
        document.body.appendChild(ov);
        document.addEventListener('keydown', onKey);
        try { video.load(); } catch (e) { }
      } catch (e) { try { showError('Preview error', e); } catch (_) { } }
    }
    document.addEventListener('click', function (ev) {
      const a = ev.target && (ev.target.closest ? ev.target.closest('a.dp-preview') : null);
      if (!a) return;
      ev.preventDefault();
      const p = a.getAttribute('data-path') || a.textContent || '';
      openPreview(p);
    });
  })();

  function appendDirRow(d) {
    if (!d || !d.header) return;
    const wrap = document.getElementById("scan-list");
    if (!wrap) return;
    let tbody = document.getElementById("scan-tbody");
    if (!tbody) {
      wrap.innerHTML = `
        <table id="scan-table" style="width:100%; border-collapse:collapse; font-size:13px">
          <thead>
            <tr>
              <th style="text-align:left">Camera</th>
              <th style="text-align:left">Date</th>
              <th style="text-align:left">Start</th>
              <th style="text-align:left">Filename</th>
            </tr>
          </thead>
          <tbody id="scan-tbody"></tbody>
        </table>`;
      tbody = document.getElementById("scan-tbody");
    }
    if (!tbody) return;
    const empty = document.getElementById("scan-empty");
    if (empty && empty.parentElement) empty.parentElement.removeChild(empty);
    const camStr = d.camera != null ? String(d.camera).padStart(2, "0") : "—";
    const tr = document.createElement("tr");
    tr.className = "scan-dir-row";
    const tdCam = document.createElement("td");
    tdCam.textContent = camStr;
    const tdPath = document.createElement("td");
    tdPath.colSpan = 3;
    const missing = d.exists === false ? " (missing)" : "";
    tdPath.textContent = `${d.path || d.root || ""}${missing}`;
    tr.appendChild(tdCam);
    tr.appendChild(tdPath);
    tbody.appendChild(tr);
  }
</script>
{% endblock %}
