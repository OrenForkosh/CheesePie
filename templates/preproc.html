{% extends "base.html" %} {% block content %}
<section class="panel">
  <div class="panel-header">
    <div>
      <h1>Preprocessing</h1>
      <p class="muted">
        Prepare a video for tracking: define arena and background.
      </p>
    </div>
  </div>

  <div class="controls" style="grid-template-columns: 2fr 1fr">
    <div class="control-group" style="grid-column: 1 / -1">
      <label>Video</label>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
        <input
          type="text"
          id="preproc-video-path"
          value="{{ video or '' }}"
          readonly
          style="flex:1"
        />
        <div id="pp-day-strip" class="muted" style="display:flex; gap:6px; flex-wrap:wrap"></div>
      </div>
    </div>

    <div class="control-group" style="grid-column: 1 / 2">
      <div class="video-wrap">
        <div class="video-preview">
          
          <div style="position: relative">
            <video
              id="pp-video"
              preload="metadata"
              {% if video %}src="/media?path={{ video|urlencode }}"{% endif %}
              style="display: block; width: 100%; height: auto"
            ></video>
            <canvas
              id="pp-processed"
              style="
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                display: none;
              "
            ></canvas>
            <canvas
              id="pp-overlay"
              style="
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                pointer-events: auto;
              "
            ></canvas>
            <div
              id="pp-handle-tl"
              style="
                position: absolute;
                width: 12px;
                height: 12px;
                background: #4f8cff;
                border: 2px solid #fff;
                border-radius: 2px;
                transform: translate(-50%, -50%);
                display: none;
                cursor: nwse-resize;
              "
            ></div>
            <div
              id="pp-handle-br"
              style="
                position: absolute;
                width: 12px;
                height: 12px;
                background: #4f8cff;
                border: 2px solid #fff;
                border-radius: 2px;
                transform: translate(-50%, -50%);
                display: none;
                cursor: nwse-resize;
              "
            ></div>
          </div>
          <div class="controls-row" style="margin-top: 8px">
            <button
              class="icon-btn"
              id="pp-play"
              title="Play"
              aria-label="Play"
              style="margin-left: 6px"
            >
              ▶
            </button>
            <div class="fill">
              <input
                type="range"
                id="pp-seek"
                min="0"
                value="0"
                step="0.01"
                style="width: 100%"
              />
            </div>
            <div
              class="muted"
              id="pp-time"
              style="
                margin-right: 6px;
                font-family: ui-monospace, Menlo, Monaco, Consolas, monospace;
              "
            >
              00:00 / 00:00
            </div>
          </div>
          <div
            class="controls-row"
            style="margin-top: 6px; align-items: center"
          >
            <label for="video-filter" class="muted">Filter</label>
            <div class="fill">
              <select id="video-filter" style="width: 100%">
                <option value="none" selected>None</option>
                <option value="invert">Invert colors</option>
                <option value="histeq">Histogram equalization</option>
              </select>
            </div>
            <span class="muted" style="min-width: 1px"></span>
          </div>
        </div>
      </div>
      
    </div>

    <div class="control-group" style="grid-column: 2 / 3">
      <div class="kv" style="margin-bottom:8px">
        <div class="k">Facility</div>
        <select id="pp-facility"></select>
        <div class="k">Setup</div>
        <div style="display:flex; gap:6px; align-items:center">
          <select id="pp-setup" style="flex:1"></select>
          <button class="btn mini" id="pp-save-setup" title="Save current settings as a setup (overwrite or add new)">Save...</button>
        </div>
        <div class="k"></div>
        <div class="v"><span id="pp-setup-status" class="muted"></span></div>
      </div>
      <div class="muted" id="pp-matlab-status" style="margin: 2px 0 8px 0">MATLAB: Checking…</div>
      <div
        class="tabs small"
        style="display: flex; gap: 8px; margin-bottom: 8px"
      >
        <button class="btn mini" id="tab-arena">Arena</button>
        <button class="btn mini" id="tab-background">Background</button>
        <button class="btn mini" id="tab-regions">Regions</button>
        <button class="btn mini" id="tab-colors">Colors</button>
        <button class="btn mini" id="tab-save">Save…</button>
      </div>
      <div id="pane-arena">
        <div class="kv">
          <div class="k">Grid cols</div>
          <input type="number" id="grid-cols" min="1" value="6" />
          <div class="k">Grid rows</div>
          <input type="number" id="grid-rows" min="1" value="4" />
          <div class="k">Width (cm)</div>
          <input type="number" id="arena-wcm" min="1" value="40" />
          <div class="k">Height (cm)</div>
          <input type="number" id="arena-hcm" min="1" value="30" />
        </div>
        <div class="muted" style="margin-top: 6px">
          Arena is axis-aligned rectangle within the frame. Click Mark to
          define: top-left then bottom-right. Drag handles to refine while
          marking. Arrow keys nudge (Shift = 10px).
        </div>
        <div
          style="display: flex; gap: 8px; align-items: center; margin-top: 8px"
        >
          <button class="btn" id="arena-mark">Mark</button>
          <span class="muted" id="arena-status"></span>
        </div>
      </div>
      <div id="pane-background" style="display: none">
        <div class="kv">
          <div class="k">Frames</div>
          <input type="number" id="bg-frames" min="5" max="200" value="25" />
          <div class="k">Quantile</div>
          <input
            type="number"
            id="bg-quant"
            min="0"
            max="100"
            step="1"
            value="50"
          />
        </div>
        <div
          style="display: flex; gap: 8px; align-items: center; margin: 8px 0"
        >
          <button class="btn" id="bg-run">Run</button>
          <button class="btn" id="bg-save">Save</button>
          <span class="muted" id="bg-status"></span>
        </div>
        <canvas
          id="bg-canvas"
          style="
            width: 100%;
            max-width: 100%;
            border: 1px solid var(--border);
            border-radius: 8px;
          "
        ></canvas>
      </div>
      <div id="pane-regions" style="display: none">
        <div id="regions-disabled-note" class="muted" style="display:none; margin: 4px 0 0 0;">
          Mark the arena first to enable Regions.
        </div>
        <div class="table-wrap" style="padding: 0; margin-top: 8px">
          <table
            id="roi-table"
            style="width: 100%; border-collapse: collapse; font-size: 13px"
          >
            <thead>
              <tr>
                <th style="text-align: left; padding: 6px">Name</th>
                <th style="text-align: left; padding: 6px">Enabled</th>
                <th style="text-align: left; padding: 6px">Sheltered</th>
                <th style="text-align: left; padding: 6px">Cells</th>
                <th style="text-align: left; padding: 6px"></th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        
        <div class="muted" style="margin-top: 6px">
          Tip: Click "Edit" for a region, then click grid cells in the
          overlay to toggle. Click again to finish.
        </div>
      </div>
      <div id="pane-colors" style="display: none">
        <div class="controls-row" style="align-items:center; gap:12px; margin: 8px 0; flex-wrap: wrap">
          <label style="display:flex; align-items:center; gap:6px">
            <input type="checkbox" id="pp-colors-segments" /> Show segments
          </label>
          <label style="display:flex; align-items:center; gap:8px">
            <span class="muted">Bounds thickness</span>
            <input type="range" id="pp-colors-thickness" min="0" max="8" step="1" value="2" />
            <span class="muted" id="pp-colors-thickness-val">2</span>
          </label>
          <button class="btn mini" id="pp-colors-remove" title="Remove mark for selected mouse in current frame">Remove mark</button>
          <button class="btn mini" id="pp-colors-clear" title="Clear all marks">Clear marks</button>
          <button class="btn mini" id="pp-colors-random" title="Jump to a random frame">Random frame</button>
          <span class="muted" id="pp-colors-status" style="min-width:200px"></span>
        </div>
        <div class="controls-row" style="align-items:center; gap:12px; margin: 8px 0; flex-wrap: wrap">
          <div id="pp-colors-selected" class="muted">Mouse: 1</div>
          <div id="pp-colors-legend" class="muted"></div>
        </div>
        <div class="controls-row" style="align-items:flex-start; gap:12px; margin: 8px 0; flex-wrap: wrap">
          <div>
            <div class="muted" style="margin-bottom:4px">Marked counts</div>
            <div id="pp-colors-hist" class="muted"></div>
          </div>
        </div>
        <div class="muted" style="margin-top: 6px">
          When open, frames are segmented by color in MATLAB (RGBY). White outlines always show cluster boundaries; enable “Show segments” to overlay colored fills.
        </div>
      </div>
      <div id="pane-save" style="display:none">
        <div class="muted" style="margin-bottom:6px">Save arena, regions, and colors to the selected days (backgrounds remain per day).</div>
        <div id="pp-mday-summary" class="muted" style="margin:6px 0">Group: —</div>
        <div id="pp-mday-list" style="max-height:160px; overflow:auto; border:1px solid var(--border); border-radius:8px; padding:6px"></div>
        <div style="display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap">
          <button class="btn mini" id="pp-mday-all">All</button>
          <button class="btn mini" id="pp-mday-none">None</button>
          <span class="muted" id="pp-mday-count"></span>
        </div>
        <div style="display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap">
          <button class="btn" id="pp-mday-save">Save preproc → selected days</button>
        </div>
        <div class="muted" id="pp-mday-status" style="margin-top:6px"></div>
      </div>
    </div>
  </div>
</section>

<script>
  window.addEventListener('DOMContentLoaded', () => {
    const videoPath = {{ (video or '')|tojson }};
    // Optional step override from query string (e.g., step=arena|background|regions)
    let urlStep = '';
    try { urlStep = new URLSearchParams(location.search).get('step') || ''; } catch {}
    const v = document.getElementById('pp-video');
    const overlay = document.getElementById('pp-overlay');
    const hTL = document.getElementById('pp-handle-tl');
    const hBR = document.getElementById('pp-handle-br');
    const arenaPane = document.getElementById('pane-arena');
    const bgPane = document.getElementById('pane-background');
    const regionsPane = document.getElementById('pane-regions');
    const colorsPane = document.getElementById('pane-colors');
    const savePane = document.getElementById('pane-save');
    const tabArena = document.getElementById('tab-arena');
    const tabBg = document.getElementById('tab-background');
    const tabRegions = document.getElementById('tab-regions');
    const tabColors = document.getElementById('tab-colors');
    const tabSave = document.getElementById('tab-save');
    const colsEl = document.getElementById('grid-cols');
    const rowsEl = document.getElementById('grid-rows');
    const wcmEl = document.getElementById('arena-wcm');
    const hcmEl = document.getElementById('arena-hcm');
    const arenaMarkBtn = document.getElementById('arena-mark');
    const arenaStatus = document.getElementById('arena-status');
    let marking = false;
    const filterSel = document.getElementById('video-filter');
    const processed = document.getElementById('pp-processed');
    const bgFramesEl = document.getElementById('bg-frames');
    const bgQuantEl = document.getElementById('bg-quant');
    const bgRunBtn = document.getElementById('bg-run');
    const bgSaveBtn = document.getElementById('bg-save');
    const bgStatus = document.getElementById('bg-status');
    const bgCanvas = document.getElementById('bg-canvas');
    // Multi-day elements
    const dayStrip = document.getElementById('pp-day-strip');
    const mdayList = document.getElementById('pp-mday-list');
    const mdaySummary = document.getElementById('pp-mday-summary');
    const mdayCount = document.getElementById('pp-mday-count');
    const mdayStatus = document.getElementById('pp-mday-status');
    let dayGroup = null; // { group, items, active }
    // Colors segmentation UI
    const colorsSegments = document.getElementById('pp-colors-segments');
    const colorsStatus = document.getElementById('pp-colors-status');
    const colorsThicknessInput = document.getElementById('pp-colors-thickness');
    const colorsThicknessVal = document.getElementById('pp-colors-thickness-val');
    const colorsSelectedEl = document.getElementById('pp-colors-selected');
    const colorsLegendEl = document.getElementById('pp-colors-legend');
    const colorsHistEl = document.getElementById('pp-colors-hist');
    let colorIndex = null;           // 2D array [h][w] of ints (0..4)
    let colorIndexSize = null;       // {w,h}
    let colorEdgesImage = null;      // offscreen canvas of white boundary pixels
    let colorSegImage = null;        // offscreen canvas of colored fills
    let colorsLoop = null;           // requestAnimationFrame handle (fallback)
    let colorsActive = false;        // whether Colors processing is active
    let colorsInFlight = false;
    let colorsLastTs = 0;
    let hasBackground = false;       // whether a background frame is available
    let colorEdgeThickness = 2;
    // Mouse/color config
    const cfg = (window.CHEESEPIE || {});
    const miceCodes = ((cfg.colors && Array.isArray(cfg.colors.mice)) ? cfg.colors.mice : ['R','G','B','Y']).slice(0,4);
    const palette = (cfg.colors && cfg.colors.palette) || { R:'#ff4f4f', G:'#34c759', B:'#4f8cff', Y:'#ffd166' };
    let selectedMouse = 1; // 1..4
    const colorMarks = []; // {mouse:1..4, code:'R', x:number, y:number, t:number}
    let colorTokens = []; // draggable tokens: [{mouse, code, x, y, homeX, homeY, docked}]
    let draggingMarkIdx = -1; // index into colorTokens while dragging
    let hoverTokenIdx = -1; // index of token under cursor
    let lastRectKey = '';

    function regionsAreValid(){
      try{
        const cols = Math.max(1, Number(colsEl.value||1));
        const rows = Math.max(1, Number(rowsEl.value||1));
        for (const it of (regionsState?.items||[])){
          const cells = (it.cells||[]).map(c => ({ r:Number(c.r)||0, c:Number(c.c)||0 }));
          if (cells.length === 0) return false;
          if (cells.some(c => c.r<0 || c.c<0 || c.r>=rows || c.c>=cols)) return false;
          if (!isConnected(cells)) return false;
        }
        return true;
      } catch { return false; }
    }
    function colorsAreValid(){
      try{
        const byMouse = new Map();
        for (const m of colorMarks){ byMouse.set(m.mouse, true); }
        for (let i=1;i<=miceCodes.length;i++){ if (!byMouse.get(i)) return false; }
        return true;
      } catch { return false; }
    }
    function sharedSaveReady(){
      return !!(state.tl && state.br) && regionsAreValid() && colorsAreValid();
    }
    function updateChipColors(){
      try{
        if (!dayGroup || !dayStrip) return;
        const okShared = sharedSaveReady();
        const byPath = new Map((dayGroup.items||[]).map(it => [it.path, it]));
        dayStrip.querySelectorAll('button.chip').forEach(ch => {
          const it = byPath.get(ch.dataset.path||'') || {};
          const can = !!okShared && !!it.has_background;
          ch.style.background = can ? '#2f9e44' : '#c92a2a';
          ch.style.color = '#fff';
          ch.style.borderColor = 'rgba(0,0,0,0.2)';
        });
      } catch {}
    }

    function ensureColorTokens(vDX, vDY, vDW, vDH, tw, th){
      const key = `${vDX},${vDY},${vDW},${vDH},${tw},${th},${miceCodes.join(',')}`;
      if (colorTokens.length !== miceCodes.length || key !== lastRectKey){
        const marginLeft = vDX;
        const marginRight = Math.max(0, tw - (vDX + vDW));
        const marginTop = vDY;
        const marginBottom = Math.max(0, th - (vDY + vDH));
        let mode = 'left';
        if (marginLeft >= 24) mode = 'left';
        else if (marginBottom >= 24) mode = 'bottom';
        else if (marginTop >= 24) mode = 'top';
        else if (marginRight >= 24) mode = 'right';
        const n = miceCodes.length;
        const spacing = 22;
        const homes = [];
        if (mode === 'left'){
          const x = Math.max(6, vDX - 12);
          const startY = Math.max(6, vDY + 16);
          for (let i=0;i<n;i++) homes.push({ x, y: startY + i*spacing });
        } else if (mode === 'right'){
          const x = Math.min(tw - 6, vDX + vDW + 12);
          const startY = Math.max(6, vDY + 16);
          for (let i=0;i<n;i++) homes.push({ x, y: startY + i*spacing });
        } else if (mode === 'top'){
          const y = Math.max(6, vDY - 12);
          const startX = Math.max(6, vDX + 16);
          for (let i=0;i<n;i++) homes.push({ x: startX + i*spacing, y });
        } else { // bottom
          const y = Math.min(th - 6, vDY + vDH + 12);
          const startX = Math.max(6, vDX + 16);
          for (let i=0;i<n;i++) homes.push({ x: startX + i*spacing, y });
        }
        colorTokens = miceCodes.map((c, i) => ({ mouse: i+1, code: c, x: homes[i].x, y: homes[i].y, homeX: homes[i].x, homeY: homes[i].y, docked: true }));
        lastRectKey = key;
      }
    }

    function dockAllTokens(){
      try{
        // Recompute homes in case layout changed
        const vw = v.videoWidth || 0, vh = v.videoHeight || 0;
        const tw = overlay.width, th = overlay.height;
        const vScale = (vw>0 && vh>0) ? Math.min(tw / vw, th / vh) : 1;
        const vDW = Math.round(vw * vScale), vDH = Math.round(vh * vScale);
        const vDX = Math.round((tw - vDW) / 2), vDY = Math.round((th - vDH) / 2);
        ensureColorTokens(vDX, vDY, vDW, vDH, tw, th);
        colorTokens.forEach(t => { t.x = t.homeX; t.y = t.homeY; t.docked = true; });
        hoverTokenIdx = -1;
        drawOverlay();
      } catch {}
    }

    function updateColorsUI(){
      try{
        const code = miceCodes[selectedMouse-1] || '?' ;
        const hex = palette[code] || '#fff';
        if (colorsSelectedEl){ colorsSelectedEl.innerHTML = `Mouse: <strong>${selectedMouse}</strong> <span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${hex};margin-left:6px;border:1px solid #000"></span> <span class="muted">(${code})</span>`; }
        if (colorsLegendEl){
          colorsLegendEl.innerHTML = miceCodes.map((c,i)=>{
            const isActive = (i+1) === selectedMouse;
            const style = isActive ? 'outline:2px solid #fff; box-shadow:0 0 0 2px rgba(0,0,0,0.35) inset; padding:2px 6px; border-radius:12px; background:rgba(255,255,255,0.08);' : '';
            return `<span data-mouse="${i+1}" style="display:inline-flex;align-items:center;gap:6px;margin-right:10px; cursor:pointer; ${style}"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${palette[c]||'#fff'}"></span><span>${i+1}:${c}</span></span>`;
          }).join('');
          // Click legend to select mouse
          Array.from(colorsLegendEl.querySelectorAll('[data-mouse]')).forEach(el => {
            el.addEventListener('click', () => {
              const m = Number(el.getAttribute('data-mouse')||'1')||1;
              selectedMouse = Math.max(1, Math.min(4, m));
              updateColorsUI();
            });
          });
        }
      } catch {}
      renderColorsHistogram();
    }

    function renderColorsHistogram(){
      try{
        const counts = { R:0, G:0, B:0, Y:0 };
        colorMarks.forEach(m => { const c = miceCodes[m.mouse-1] || 'R'; counts[c] = (counts[c]||0)+1; });
        const html = miceCodes.map(c => {
          const v = counts[c]||0; const hex = palette[c]||'#fff';
          return `<div style="display:flex;align-items:center;gap:6px;margin:2px 0"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${hex}"></span><span style="min-width:24px">${c}</span><span>${v}</span></div>`;
        }).join('');
        if (colorsHistEl){ colorsHistEl.innerHTML = html; }
      } catch {}
    }

    // Load saved thickness
    try {
      const t = Number(localStorage.getItem('cheesepie.preproc.colors.edge_thickness')||'');
      if (Number.isFinite(t) && t>=0){ colorEdgeThickness = Math.max(0, Math.min(8, Math.round(t))); }
    } catch {}
    try {
      if (colorsThicknessInput){ colorsThicknessInput.value = String(colorEdgeThickness); }
      if (colorsThicknessVal){ colorsThicknessVal.textContent = String(colorEdgeThickness); }
    } catch {}

    // --- MATLAB status poll ---
    const matlabStatusEl = document.getElementById('pp-matlab-status');
    async function refreshMatlabStatus(){
      try{
        const r = await fetch('/api/matlab/status', { cache: 'no-store' });
        const d = await r.json();
        if (!r.ok || d.error){
          matlabStatusEl.textContent = 'MATLAB: Error';
          if (d && d.error) matlabStatusEl.textContent += ' - ' + d.error;
          return;
        }
        if (!d.enabled){ matlabStatusEl.textContent = 'MATLAB: Disabled'; return; }
        if (d.ready){ matlabStatusEl.textContent = 'MATLAB: Ready'; return; }
        matlabStatusEl.textContent = 'MATLAB: Starting…';
      } catch {
        matlabStatusEl.textContent = 'MATLAB: Unreachable';
      }
    }
    refreshMatlabStatus();
    setInterval(refreshMatlabStatus, 2000);

    // --- Tab selection state (visual) ---
    function setActivePreprocTab(name){
      [tabArena, tabBg, tabRegions, tabColors, tabSave].forEach(btn => { try { btn && btn.classList.remove('primary'); } catch {}});
      try{
        if (name === 'arena') tabArena?.classList.add('primary');
        else if (name === 'background') tabBg?.classList.add('primary');
        else if (name === 'regions') tabRegions?.classList.add('primary');
        else if (name === 'colors') tabColors?.classList.add('primary');
        else if (name === 'save') tabSave?.classList.add('primary');
      } catch{}
    }
    // MATLAB segmentation (per-frame Colors tab only)
    const saveSetupBtn = document.getElementById('pp-save-setup');
    const setupStatus = document.getElementById('pp-setup-status');
    // Regions UI elements and state
    // Global facility/setup controls
    const roiFacilitySel = document.getElementById('pp-facility');
    const roiSetSel = document.getElementById('pp-setup');
    const roiTableBody = document.querySelector('#roi-table tbody');
    // Removed Move ROI and Save Regions controls
    let regionsState = null; // { facility, set, items:[{name, enabled, sheltered, cells:[{r,c}]}] }
    let editingRoiIndex = -1;
    // Move ROI mode removed

    if (videoPath){
      try { v.pause(); } catch {}
      try { v.removeAttribute('src'); } catch {}
      v.innerHTML = '';
      v.src = `/media?path=${encodeURIComponent(videoPath)}`;
      v.load();
      setTimeout(() => { try { if (v.readyState >= 1) onVideoLoadedMetadata(); } catch {} }, 0);
    // Populate day group
    async function loadDayGroup(){
      if (!videoPath || !dayStrip || !mdayList) return;
      try{
        const r = await fetch(`/api/preproc/group?video=${encodeURIComponent(videoPath)}`);
        const d = await r.json();
        if (!r.ok || d.error){ dayStrip.textContent = 'Group: unavailable'; return; }
        const items = Array.isArray(d.items) ? d.items : [];
        dayGroup = { group: d.group, items, active: d.active };
        // Strip chips
        dayStrip.innerHTML = '';
        items.forEach(it => {
          const chip = document.createElement('button');
          chip.className = 'chip'; chip.textContent = `Day${it.day}`; chip.title = it.name; chip.dataset.path = it.path;
          if (it.path === d.active) chip.classList.add('active');
          chip.addEventListener('click', () => {
            const step = (localStorage.getItem('cheesepie.preproc.step')||'');
            window.location.href = `/preproc?video=${encodeURIComponent(it.path)}${step?`&step=${encodeURIComponent(step)}`:''}`;
          });
          dayStrip.appendChild(chip);
        });
        // After rendering chips, color-code by savability
        updateChipColors();
        // Selection list
        mdaySummary.textContent = `Group: ${d.group || '—'}`;
        mdayList.innerHTML = '';
        items.forEach(it => {
          const row = document.createElement('div');
          row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px'; row.style.padding = '2px 0';
          row.innerHTML = `
            <input type="checkbox" data-path="${it.path}">
            <span style="min-width:58px">Day${it.day}</span>
            <span class="muted" style="font-size:12px">${it.has_background?'bg ✓':'bg —'}</span>
          `;
          mdayList.appendChild(row);
        });
        // Restore previous selection for this group
        try{
          const key = `cheesepie.preproc.mday.sel.${d.group}`;
          const saved = JSON.parse(localStorage.getItem(key) || '[]');
          const set = new Set(saved);
          mdayList.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = set.has(cb.getAttribute('data-path')); });
        } catch{}
        updateMdayCount();
        document.getElementById('pp-mday-all')?.addEventListener('click', () => { mdayList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); updateMdayCount(); saveMdaySelection(); });
        document.getElementById('pp-mday-none')?.addEventListener('click', () => { mdayList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); updateMdayCount(); saveMdaySelection(); });
        mdayList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.addEventListener('change', () => { updateMdayCount(); saveMdaySelection(); }));
      } catch { dayStrip.textContent = 'Group: unavailable'; }
    }
    function updateMdayCount(){ try{ const n = mdayList.querySelectorAll('input[type="checkbox"]:checked').length; mdayCount.textContent = `${n} selected`; } catch{} }
    function getSelectedPaths(){ return Array.from(mdayList.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.getAttribute('data-path')); }
    function saveMdaySelection(){ try{ if (!dayGroup) return; const key = `cheesepie.preproc.mday.sel.${dayGroup.group}`; localStorage.setItem(key, JSON.stringify(getSelectedPaths())); } catch{} }
    loadDayGroup();
    // Apply current settings → selected days
    document.getElementById('pp-mday-apply')?.addEventListener('click', async () => {
      if (!dayGroup){ mdayStatus.textContent = 'No group'; return; }
      const targets = getSelectedPaths().filter(p => p && p !== dayGroup.active);
      if (!targets.length){ mdayStatus.textContent = 'Select at least one day'; return; }
      // Overwrite check: any target with existing arena/preproc?
      const byPath = new Map(dayGroup.items.map(it => [it.path, it]));
      const risky = targets.filter(p => { const it = byPath.get(p)||{}; return it.has_arena || it.has_preproc; });
      if (risky.length){
        const ok = confirm(`Overwrite arena/regions for ${risky.length} day(s)?`);
        if (!ok) return;
      }
      mdayStatus.textContent = 'Applying settings…';
      try{
        const r = await fetch('/api/preproc/apply_settings', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ from: dayGroup.active, to: targets }) });
        const d = await r.json();
        if (!r.ok || d.error){ mdayStatus.textContent = 'Error: ' + (d.error || r.statusText); return; }
        const okN = (d.results||[]).filter(x => x.ok).length;
        mdayStatus.textContent = `Applied to ${okN}/${targets.length}`;
        loadDayGroup();
      } catch(e){ mdayStatus.textContent = 'Error: ' + e; }
    });
    // Recompute backgrounds → selected days
    document.getElementById('pp-mday-bg')?.addEventListener('click', async () => {
      const targets = getSelectedPaths();
      if (!targets.length){ mdayStatus.textContent = 'Select at least one day'; return; }
      mdayStatus.textContent = `Recomputing backgrounds 0/${targets.length}…`;
      let done = 0;
      for (const path of targets){
        try{
          await recomputeBackgroundForVideo(path);
          done++;
          mdayStatus.textContent = `Recomputing backgrounds ${done}/${targets.length}…`;
        } catch(e){ mdayStatus.textContent = `Error on ${path}: ${e}`; }
      }
      mdayStatus.textContent = `Backgrounds done (${done}/${targets.length})`;
      loadDayGroup();
    });
    async function recomputeBackgroundForVideo(path){
      const hv = document.createElement('video'); hv.muted = true; hv.preload = 'auto'; hv.playsInline = true; hv.crossOrigin = 'anonymous';
      hv.style.position = 'fixed'; hv.style.left = '-9999px'; hv.style.top = '0'; hv.style.width = '160px'; hv.style.visibility = 'hidden';
      const src = document.createElement('source'); src.src = `/media?path=${encodeURIComponent(path)}`; hv.appendChild(src);
      document.body.appendChild(hv);
      const N = Math.max(5, Math.min(200, Number(bgFramesEl.value || 25)));
      const qPct = Math.max(0, Math.min(100, Number(bgQuantEl.value || 50)))/100;
      await new Promise((res)=>{ hv.addEventListener('loadedmetadata', res, {once:true}); hv.load(); });
      const maxW = 640; const scale = Math.min(1, maxW / (hv.videoWidth||maxW));
      const w = Math.max(1, Math.round((hv.videoWidth||maxW) * scale));
      const h = Math.max(1, Math.round((hv.videoHeight||maxW*9/16) * scale));
      const work = document.createElement('canvas'); work.width = w; work.height = h; const wctx = work.getContext('2d');
      const times = new Set(); const dur = Math.max(0.2, Number(hv.duration||0));
      while (times.size < N){ times.add(Math.random() * Math.max(0.1, dur - 0.2) + 0.1); }
      const arrTimes = Array.from(times).slice(0, N).sort((a,b)=>a-b);
      const frames = [];
      for (const t of arrTimes){
        await new Promise((resolve) => {
          const onSeeked = () => { try{ wctx.drawImage(hv, 0, 0, w, h); const id = wctx.getImageData(0,0,w,h); frames.push(id.data); }catch{} hv.removeEventListener('seeked', onSeeked); resolve(); };
          hv.addEventListener('seeked', onSeeked);
          try{ hv.currentTime = Math.min(Math.max(0.05, t), Math.max(0.05, dur-0.05)); } catch{ hv.removeEventListener('seeked', onSeeked); resolve(); }
        });
      }
      if (frames.length === 0) throw new Error('No frames');
      const out = new Uint8ClampedArray(w*h*4); const K = frames.length; const qi = Math.max(0, Math.min(K-1, Math.round(qPct * (K-1))));
      for (let i=0, p=0; i<w*h; i++, p+=4){
        const r = new Uint8Array(K), g = new Uint8Array(K), b = new Uint8Array(K), a = new Uint8Array(K);
        for (let k=0;k<K;k++){ const f = frames[k]; r[k]=f[p]; g[k]=f[p+1]; b[k]=f[p+2]; a[k]=f[p+3]; }
        r.sort(); g.sort(); b.sort(); a.sort();
        out[p]=r[qi]; out[p+1]=g[qi]; out[p+2]=b[qi]; out[p+3]=255;
      }
      const img = new ImageData(out, w, h); wctx.putImageData(img, 0, 0);
      const dataUrl = work.toDataURL('image/png');
      const resp = await fetch('/api/preproc/background', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ video: path, image: dataUrl }) });
      const jd = await resp.json(); if (!resp.ok || jd.error) throw new Error(jd.error || resp.statusText);
      try{ document.body.removeChild(hv); } catch{}
    }
    // Save shared settings (Arena/Regions/Colors) → selected days
    document.getElementById('pp-mday-save')?.addEventListener('click', async () => {
      if (!dayGroup){ mdayStatus.textContent = 'No group'; showModal('Cannot Save','No group of days is available for this video.') return; }
      const targets = getSelectedPaths();
      if (!targets.length){ mdayStatus.textContent = 'Select at least one day'; showModal('Cannot Save','Select at least one day to save to.') return; }
      // Validate backgrounds present for all selected
      const byPath = new Map(dayGroup.items.map(it => [it.path, it]));
      const missingBg = targets.filter(p => !(byPath.get(p)||{}).has_background);
      if (missingBg.length){ mdayStatus.textContent = `Missing background on ${missingBg.length} selected day(s)`; showModal('Cannot Save',`Missing background on ${missingBg.length} selected day(s). Compute background first.`) return; }
      // Validate Arena
      if (!(state.tl && state.br)){ mdayStatus.textContent = 'Please mark the Arena first'; showModal('Cannot Save','Please mark the Arena first.') return; }
      // Validate Regions: every item must have in-bounds and connected cells (reuse quick checks)
      try{
        const cols = Math.max(1, Number(colsEl.value||1));
        const rows = Math.max(1, Number(rowsEl.value||1));
        for (const it of (regionsState?.items||[])){
          const cells = (it.cells||[]).map(c => ({ r:Number(c.r)||0, c:Number(c.c)||0 }));
          if (cells.some(c => c.r<0 || c.c<0 || c.r>=rows || c.c>=cols)){
            const msg = `ROI "${it.name}": contains out-of-bounds cells`; mdayStatus.textContent = msg; showModal('Cannot Save', msg) return;
          }
          if (cells.length===0){ const msg = `ROI "${it.name}": no cells marked`; mdayStatus.textContent = msg; showModal('Cannot Save', msg) return; }
          if (!isConnected(cells)){ const msg = `ROI "${it.name}": cells must be connected`; mdayStatus.textContent = msg; showModal('Cannot Save', msg) return; }
        }
      } catch(e){ /* fall-through */ }
      // Validate Colors: at least one mark per mouse
      const byMouse = new Map();
      for (const m of colorMarks){ byMouse.set(m.mouse, true); }
      let ok = true;
      for (let i=1;i<=miceCodes.length;i++){ if (!byMouse.get(i)){ ok = false; break; } }
      if (!ok){ mdayStatus.textContent = 'Colors: add at least one mark per mouse'; return; }
      const payload = {
        targets,
        preproc: {
          arena: {
            tl: state.tl, br: state.br,
            cols: Math.max(1, Number(colsEl.value||1)),
            rows: Math.max(1, Number(rowsEl.value||1)),
            width_cm: Math.max(0, Number(wcmEl.value||0)),
            height_cm: Math.max(0, Number(hcmEl.value||0)),
          },
          regions: regionsState,
          colors: { mice: miceCodes, palette, marks: colorMarks },
        }
      };
      mdayStatus.textContent = 'Saving…';
      try{
        const r = await fetch('/api/preproc/save_multi', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const d = await r.json();
        if (!r.ok || d.error){ const msg = (d && d.error) || r.statusText || 'Save failed'; mdayStatus.textContent = 'Error: ' + msg; showModal('Save Failed', msg) return; }
        mdayStatus.textContent = `Saved ${d.saved||0}/${targets.length}`;
      } catch(e){ mdayStatus.textContent = 'Error: ' + e; showModal('Save Failed', String(e)) }
    });
    }
    // External controls
    const playBtn = document.getElementById('pp-play');
    const seek = document.getElementById('pp-seek');
    const timeLbl = document.getElementById('pp-time');
    function fmtTime(sec){
      if (!isFinite(sec)) return '00:00:00.000';
      const totalMs = Math.max(0, Math.round(sec * 1000));
      const h = Math.floor(totalMs / 3600000);
      const rem = totalMs % 3600000;
      const m = Math.floor(rem / 60000);
      const rem2 = rem % 60000;
      const s = Math.floor(rem2 / 1000);
      const ms = rem2 % 1000;
      const pad2 = (n) => String(n).padStart(2, '0');
      const pad3 = (n) => String(n).padStart(3, '0');
      return `${pad2(h)}:${pad2(m)}:${pad2(s)}.${pad3(ms)}`;
    }
    // Persist preproc context per video
    const PCTX_KEY = 'ppctx:' + (videoPath || '');
    function savePctx(){ try { localStorage.setItem(PCTX_KEY, JSON.stringify({ t: v.currentTime||0, f: filterSel.value||'none' })); } catch {} }
    function loadPctx(){ try { const raw = localStorage.getItem(PCTX_KEY); return raw? JSON.parse(raw) : null; } catch { return null; } }

    function onVideoLoadedMetadata(){
      seek.max = String(Math.max(0, v.duration||0));
      const ctx = loadPctx();
      if (ctx){
        try { v.currentTime = Math.max(0, Math.min((v.duration||0)-0.05, Number(ctx.t)||0)); } catch {}
        if (ctx.f){ try { filterSel.value = ctx.f; applyFilter(); } catch {} }
      }
      timeLbl.textContent = `${fmtTime(v.currentTime||0)} / ${fmtTime(v.duration||0)}`;
      resizeOverlay();
    }
    v.addEventListener('loadedmetadata', onVideoLoadedMetadata);
    v.addEventListener('timeupdate', () => {
      if (!seek.dragging) { seek.value = String(v.currentTime||0); }
      timeLbl.textContent = `${fmtTime(v.currentTime||0)} / ${fmtTime(v.duration||0)}`;
      savePctx();
    });
    function updatePlayUI(){
      const isPaused = v.paused;
      playBtn.textContent = isPaused ? '▶' : '⏸';
      playBtn.title = isPaused ? 'Play' : 'Pause';
      playBtn.setAttribute('aria-label', isPaused ? 'Play' : 'Pause');
    }
    playBtn.addEventListener('click', () => { if (v.paused) { v.play(); } else { v.pause(); } });
    v.addEventListener('play', updatePlayUI);
    v.addEventListener('pause', updatePlayUI);
    v.addEventListener('loadedmetadata', updatePlayUI);
    seek.addEventListener('input', () => { seek.dragging = true; v.currentTime = Number(seek.value||0); });
    seek.addEventListener('change', () => { seek.dragging = false; savePctx(); });
    // Default: allow interacting with video controls when not marking
    overlay.style.pointerEvents = 'none';
    // Handles always interactive
    hTL.style.pointerEvents = 'auto';
    hBR.style.pointerEvents = 'auto';
    // Processed canvas starts hidden
    processed.style.display = 'none';
    // Helper: check arena availability
    function hasArena(){ return !!(state.tl && state.br); }
    // Initialize Regions UI with defaults
    try {
      regionsState = defaultRegionsState();
      populateRoiFacility();
      populateRoiSets();
      applySetupDefaults();
      renderRoiUI();
      updateTabEnablement();
      roiFacilitySel?.addEventListener('change', () => { regionsState.facility = roiFacilitySel.value; populateRoiSets(); applySetupDefaults(); renderRoiUI(); drawOverlay(); updateTabEnablement(); });
      roiSetSel?.addEventListener('change', () => { regionsState.set = roiSetSel.value; applySetupDefaults(); renderRoiUI(); drawOverlay(); updateTabEnablement(); });
      // Removed Move ROI toggle and Save Regions button/listeners
    } catch {}
    // Wire Save... button even if init block failed
    try { saveSetupBtn?.addEventListener('click', onSaveSetup); } catch {}
    // If native prompts are blocked in this environment, fallback to custom modal
    // Replace handler to open a lightweight modal
    try {
      saveSetupBtn?.removeEventListener('click', onSaveSetup);
    } catch {}
    try {
      saveSetupBtn?.addEventListener('click', () => {
        try{
          // Create drawer lazily if missing
          let backdrop = document.getElementById('pp-save-backdrop');
          let drawer = document.getElementById('pp-save-drawer');
          if (!backdrop){
            backdrop = document.createElement('div');
            backdrop.id = 'pp-save-backdrop';
            backdrop.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:none;z-index:9998;';
            document.body.appendChild(backdrop);
          }
          if (!drawer){
            drawer = document.createElement('div');
            drawer.id = 'pp-save-drawer';
            drawer.style.cssText = 'position:fixed;top:0;right:0;height:100%;width:380px;max-width:92%;background:var(--panel);color:var(--text);box-shadow:-8px 0 24px var(--shadow);transform:translateX(100%);transition:transform 220ms ease;z-index:9999;display:flex;flex-direction:column;border-left:1px solid var(--border);';
            drawer.innerHTML = `
              <div style="display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid var(--border)">
                <div style="font-weight:600">Save Setup</div>
                <button class="btn mini" id="pp-save-close" type="button" aria-label="Close">✕</button>
              </div>
              <div style="padding:14px 16px;flex:1;overflow:auto">
                <label class="muted" style="font-size:12px">Setup name</label>
                <input id="pp-save-name" type="text" style="width:100%;margin:6px 0 10px 0;padding:8px 10px;border:1px solid var(--border);border-radius:8px;background:var(--surface);color:var(--text)" />
                <div class="muted" id="pp-save-hint" style="margin-top:6px;font-size:12px">If a setup with this name exists, it will be overwritten; otherwise a new setup will be created.</div>
                <div id="pp-save-preview" style="margin-top:12px;border-top:1px dashed var(--border);padding-top:12px;font-size:12px;color:var(--muted)"></div>
              </div>
              <div style="padding:12px 16px;border-top:1px solid var(--border);display:flex;gap:8px;justify-content:flex-end">
                <button class="btn mini" id="pp-save-cancel" type="button">Cancel</button>
                <button class="btn mini primary" id="pp-save-confirm" type="button">Save</button>
              </div>`;
            document.body.appendChild(drawer);
          }
          const nameInput = document.getElementById('pp-save-name');
          const cancelBtn = document.getElementById('pp-save-cancel');
          const confirmBtn = document.getElementById('pp-save-confirm');
          const closeBtn = document.getElementById('pp-save-close');
          // Open drawer
          backdrop.style.display = 'block';
          try { document.body.style.overflow = 'hidden'; } catch {}
          requestAnimationFrame(()=>{ try{ drawer.style.transform = 'translateX(0)'; }catch{} });
          if (nameInput){ nameInput.value = roiSetSel?.value || 'Default'; setTimeout(()=>{ try{ nameInput.focus(); nameInput.select(); }catch{} }, 50); }
          // Name status / overwrite hint and dynamic Save label, plus preview
          const hintEl = document.getElementById('pp-save-hint');
          const previewEl = document.getElementById('pp-save-preview');
          function refreshSaveState(){
            const facs = (window.CHEESEPIE && window.CHEESEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
            const facility = roiFacilitySel?.value || '';
            const sets = (((facs[facility]||{}).roi_sets)||[]);
            const val = String(nameInput?.value||'').trim();
            const exists = !!sets.find(s => (s&&s.name)===val);
            if (confirmBtn){ confirmBtn.textContent = exists ? 'Overwrite' : 'Save'; confirmBtn.disabled = val.length===0; }
            if (hintEl){ hintEl.textContent = exists ? 'This will overwrite the existing setup.' : 'A new setup will be created with this name.'; }
            // Preview summary
            try{
              const cols = Math.max(1, Number(colsEl.value||1));
              const rows = Math.max(1, Number(rowsEl.value||1));
              const wcm = Math.max(0, Number(wcmEl.value||0));
              const hcm = Math.max(0, Number(hcmEl.value||0));
              const bgf = Math.max(1, Number(bgFramesEl.value||1));
              const bgq = Math.max(0, Math.min(100, Number(bgQuantEl.value||0)));
              const roiCount = (regionsState?.items||[]).length;
              const withCells = (regionsState?.items||[]).filter(it => (it.cells||[]).length>0);
              const names = withCells.slice(0,4).map(it => `${it.name}(${it.cells.length})`).join(', ');
              const more = withCells.length>4 ? `, +${withCells.length-4} more` : '';
              previewEl.innerHTML = `
                <div style="margin-bottom:8px"><span class="badge"><span class="dot"></span>Preview</span></div>
                <div>Arena: ${wcm}×${hcm} cm · Grid: ${cols}×${rows}</div>
                <div>Background: ${bgf} frames · q=${bgq}%</div>
                <div>ROIs: ${roiCount} (${withCells.length} with cells${withCells.length?`: ${names}${more}`:''})</div>
              `;
            } catch {}
          }
          try{ nameInput?.addEventListener('input', refreshSaveState); refreshSaveState(); } catch {}
          // Focus trap inside drawer
          function trapTab(ev){
            if (ev.key !== 'Tab') return;
            const focusables = drawer.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            const list = Array.from(focusables).filter(el => !el.hasAttribute('disabled'));
            if (!list.length) return;
            const first = list[0]; const last = list[list.length-1];
            if (ev.shiftKey && document.activeElement === first){ ev.preventDefault(); last.focus(); }
            else if (!ev.shiftKey && document.activeElement === last){ ev.preventDefault(); first.focus(); }
          }
          document.addEventListener('keydown', trapTab);
          function close(){
            try{ drawer.style.transform = 'translateX(100%)'; }catch{}
            setTimeout(()=>{ try{ backdrop.style.display = 'none'; document.body.style.overflow=''; saveSetupBtn?.focus(); document.removeEventListener('keydown', trapTab); }catch{} }, 200);
          }
          // Close on background click
          backdrop.onclick = (e) => { try{ if (e.target === backdrop) close(); }catch{} };
          cancelBtn?.addEventListener('click', close, { once:true });
          closeBtn?.addEventListener('click', close, { once:true });
          nameInput?.addEventListener('keydown', (ev)=>{ if (ev.key==='Escape'){ ev.preventDefault(); close(); } if (ev.key==='Enter'){ ev.preventDefault(); confirmBtn?.click(); } });
          confirmBtn?.addEventListener('click', async () => {
            const name = (nameInput?.value||'').trim(); if (!name) return;
            try { window.__ppSaveName = name; } catch {}
            await onSaveSetup();
            close();
          }, { once:true });
        } catch {}
      });
    } catch {}
    // Frame step helpers
    let preprocFps = 30;
    fetch(`/api/media_meta?path=${encodeURIComponent(videoPath||'')}`).then(r=>r.json()).then(meta => {
      const f = meta && meta.streams && meta.streams.video && meta.streams.video.fps;
      if (typeof f === 'number' && isFinite(f) && f>0) preprocFps = f;
    }).catch(()=>{});
    function stepFrames(n){ const dt = 1/Math.max(1, preprocFps); v.pause(); try{ v.currentTime = Math.max(0, Math.min((v.duration||0), (v.currentTime||0) + n*dt)); }catch{} }
    function seekSeconds(d){ try{ v.currentTime = Math.max(0, Math.min((v.duration||0), (v.currentTime||0) + d)); }catch{} }
    document.getElementById('pp-step-back')?.addEventListener('click', ()=> stepFrames(-1));
    document.getElementById('pp-step-fwd')?.addEventListener('click', ()=> stepFrames(+1));
    document.getElementById('pp-seek-back')?.addEventListener('click', ()=> seekSeconds(-10));
    document.getElementById('pp-seek-fwd')?.addEventListener('click', ()=> seekSeconds(+10));
    function gotoRandomFrame(){
      try{
        const dur = Number(v.duration||0);
        if (!isFinite(dur) || dur<=0) return;
        const t = Math.random() * Math.max(0, dur - 0.2) + 0.1;
        v.pause(); v.currentTime = Math.max(0.1, Math.min(dur-0.1, t));
      } catch{}
    }
    document.getElementById('pp-colors-random')?.addEventListener('click', gotoRandomFrame);
    // Reset tokens on frame change and re-run segmentation once
    let lastFrameT = -1;
    function onFrameChange(){ dockAllTokens(); try { processColorsFrame(); } catch {} }
    v.addEventListener('seeked', () => { if (colorsPane && colorsPane.style.display !== 'none') onFrameChange(); }
    v.addEventListener('loadedmetadata', onVideoLoadedMetadata);
    v.addEventListener('timeupdate', () => {
      if (!(colorsPane && colorsPane.style.display !== 'none')) return;
      const t = Number(v.currentTime||0);
      const dt = 1/Math.max(1, preprocFps||30);
      if (Math.abs(t - lastFrameT) > dt/2){ lastFrameT = t; onFrameChange(); }
    });
    window.addEventListener('keydown', (ev)=>{
      const tag = (ev.target && ev.target.tagName || '').toLowerCase();
      if (tag === 'input' || tag === 'select' || tag === 'textarea') return;
      if (marking) return;
      // Colors tab: number keys 1..4 select mouse
      if (colorsPane && colorsPane.style.display !== 'none'){
        if (ev.key === ' '){ ev.preventDefault(); gotoRandomFrame(); return; }
        const k = ev.key;
        if (k >= '1' && k <= '4'){
          ev.preventDefault();
          selectedMouse = Math.max(1, Math.min(4, Number(k)));
          updateColorsUI();
          return;
        }
      }
      // Stop ROI editing on Enter
      if (ev.key === 'Enter' && editingRoiIndex >= 0){
        ev.preventDefault();
        editingRoiIndex = -1; renderRoiUI(); drawOverlay();
        return;
      }
      if (ev.key === ' '){ ev.preventDefault(); if (v.paused) v.play(); else v.pause(); return; }
      if (ev.key === ','){ ev.preventDefault(); stepFrames(-1); return; }
      if (ev.key === '.'){ ev.preventDefault(); stepFrames(+1); return; }
      if (ev.key.toLowerCase() === 'j'){ ev.preventDefault(); seekSeconds(-10); return; }
      if (ev.key.toLowerCase() === 'l'){ ev.preventDefault(); seekSeconds(+10); return; }
    });

    // Arena selection state (video-space pixels)
    const state = { tl: null, br: null };
    let hoverBR = null; // provisional bottom-right while marking
    let dragging = null; // 'tl' or 'br'

    function resizeOverlay(){
      const rect = v.getBoundingClientRect();
      overlay.width = rect.width; overlay.height = rect.height;
      processed.width = rect.width; processed.height = rect.height;
      drawOverlay();
    }
    window.addEventListener('resize', resizeOverlay);
    v.addEventListener('loadedmetadata', resizeOverlay);
    v.addEventListener('resize', resizeOverlay);

    function buildColorEdges(){
      try{
        if (!colorIndex || !colorIndexSize) return null;
        const w = colorIndexSize.w|0, h = colorIndexSize.h|0;
        if (w<=0 || h<=0) return null;
        const thick = Math.max(0, Number(colorEdgeThickness)||0);
        if (thick <= 0){ colorEdgesImage = null; return; }
        const off = document.createElement('canvas'); off.width = w; off.height = h;
        const octx = off.getContext('2d');
        const img = octx.createImageData(w, h);
        const data = img.data;
        for (let y=0; y<h; y++){
          const row = colorIndex[y] || [];
          const rowUp = (y>0) ? (colorIndex[y-1] || []) : [];
          const rowDown = (y+1<h) ? (colorIndex[y+1] || []) : [];
          for (let x=0; x<w; x++){
            const v = row[x]|0;
            if (!v) continue;
            // Check neighbors and draw OUTWARD only (into non-v regions)
            // Left side
            const vL = (x>0) ? (row[x-1]|0) : 0;
            if (vL !== v){
              for (let t=1; t<=thick; t++){
                const xx = x - t; if (xx < 0) break;
                const ii = (y*w + xx)*4; data[ii]=255; data[ii+1]=255; data[ii+2]=255; data[ii+3]=255;
              }
            }
            // Right side
            const vR = (x+1<w) ? (row[x+1]|0) : 0;
            if (vR !== v){
              for (let t=1; t<=thick; t++){
                const xx = x + t; if (xx >= w) break;
                const ii = (y*w + xx)*4; data[ii]=255; data[ii+1]=255; data[ii+2]=255; data[ii+3]=255;
              }
            }
            // Up side
            const vU = (y>0) ? (rowUp[x]|0) : 0;
            if (vU !== v){
              for (let t=1; t<=thick; t++){
                const yy = y - t; if (yy < 0) break;
                const ii = (yy*w + x)*4; data[ii]=255; data[ii+1]=255; data[ii+2]=255; data[ii+3]=255;
              }
            }
            // Down side
            const vD = (y+1<h) ? (rowDown[x]|0) : 0;
            if (vD !== v){
              for (let t=1; t<=thick; t++){
                const yy = y + t; if (yy >= h) break;
                const ii = (yy*w + x)*4; data[ii]=255; data[ii+1]=255; data[ii+2]=255; data[ii+3]=255;
              }
            }
          }
        }
        octx.putImageData(img, 0, 0);
        colorEdgesImage = off;
        // build colored segments
        const off2 = document.createElement('canvas'); off2.width = w; off2.height = h;
        const octx2 = off2.getContext('2d');
        const img2 = octx2.createImageData(w, h);
        const d2 = img2.data;
        const palette = [ null, [255,64,64,80], [64,255,64,80], [64,64,255,80], [255,255,64,80] ];
        for (let y=0; y<h; y++){
          const row = colorIndex[y] || [];
          for (let x=0; x<w; x++){
            const v = row[x]|0;
            if (v>0){
              const i = (y*w + x)*4; const c = palette[v] || [255,255,255,60];
              d2[i]=c[0]; d2[i+1]=c[1]; d2[i+2]=c[2]; d2[i+3]=c[3];
            }
          }
        }
        octx2.putImageData(img2, 0, 0);
        colorSegImage = off2;
      } catch { colorEdgesImage = null; colorSegImage = null; }
    }

    function drawOverlay(){
      const ctx = overlay.getContext('2d');
      ctx.clearRect(0,0,overlay.width, overlay.height);
      // Draw ROI cell highlights if available
      const rect = v.getBoundingClientRect();
      const scaleX = rect.width / (v.videoWidth||1);
      const scaleY = rect.height / (v.videoHeight||1);
      const isColors = (colorsPane && colorsPane.style.display !== 'none');
      // Compute how the video content maps into the overlay (preserve aspect ratio + center)
      const vw = v.videoWidth || 0, vh = v.videoHeight || 0;
      const tw = overlay.width, th = overlay.height;
      const vScale = (vw>0 && vh>0) ? Math.min(tw / vw, th / vh) : 1;
      const vDW = Math.round(vw * vScale), vDH = Math.round(vh * vScale);
      const vDX = Math.round((tw - vDW) / 2), vDY = Math.round((th - vDH) / 2);

      // (Masked segmentation removed)
      // Draw color cluster boundaries (white) - always show
      if (colorEdgesImage){
        if (tw>0 && th>0){
          ctx.save();
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(colorEdgesImage, 0, 0, colorEdgesImage.width, colorEdgesImage.height, vDX, vDY, vDW, vDH);
          ctx.restore();
        }
      }
      // Draw filled segments if enabled
      if (colorsSegments && colorsSegments.checked && colorSegImage){
        if (tw>0 && th>0){
          ctx.save();
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(colorSegImage, 0, 0, colorSegImage.width, colorSegImage.height, vDX, vDY, vDW, vDH);
          ctx.restore();
        }
      }
      // Draw draggable tokens (always visible in Colors)
      if (isColors){
        ensureColorTokens(vDX, vDY, vDW, vDH, tw, th);
        ctx.save();
        colorTokens.forEach((tkn, idx) => {
          const hex = palette[tkn.code] || '#fff';
          ctx.fillStyle = hex;
          ctx.beginPath(); ctx.arc(tkn.x, tkn.y, 6, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();
          if (idx === hoverTokenIdx && draggingMarkIdx < 0){
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(tkn.x, tkn.y, 9, 0, Math.PI*2); ctx.stroke();
          }
        });
        ctx.restore();
      }
      // (Blob overlay removed)
      const isRegions = (regionsPane && regionsPane.style.display !== 'none');
      if (isRegions && regionsState && regionsState.items && state.tl && (state.br || hoverBR)){
        // Always draw all ROIs: fill assigned cells, outline bounding box, and label name
        const cols = Math.max(1, Number(colsEl.value||1));
        const rows = Math.max(1, Number(rowsEl.value||1));
        const arX = state.tl.x * scaleX;
        const arY = state.tl.y * scaleY;
        const arW = ((state.br || hoverBR).x - state.tl.x) * scaleX;
        const arH = ((state.br || hoverBR).y - state.tl.y) * scaleY;
        const palette = ['#4f8cff','#ff6b6b','#ffd166','#7cd67c','#a66cff','#34c759','#2aa9ff','#ff5cab','#00d1c7','#ff9f1a','#00c2a8'];
        regionsState.items.forEach((it, i) => {
          const color = palette[i % palette.length];
          const cells = it.cells || [];
          if (cells.length === 0) return;
          // Fill cells
          const alpha = (editingRoiIndex===i) ? 0.35 : 0.20;
          ctx.fillStyle = hexToRgba(color, alpha);
          let minC=Infinity, minR=Infinity, maxC=-Infinity, maxR=-Infinity;
          cells.forEach(cell => {
            const cx = Number(cell.c)||0;
            const cy = Number(cell.r)||0;
            minC = Math.min(minC, cx); maxC = Math.max(maxC, cx);
            minR = Math.min(minR, cy); maxR = Math.max(maxR, cy);
            const x = arX + (arW * cx / cols);
            const y = arY + (arH * cy / rows);
            const w = arW / cols;
            const h = arH / rows;
            ctx.fillRect(Math.round(x)+0.5, Math.round(y)+0.5, Math.round(w)-1, Math.round(h)-1);
          });
          if (isFinite(minC) && isFinite(minR) && isFinite(maxC) && isFinite(maxR)){
            // Outline bbox
            const bx = arX + (arW * minC / cols);
            const by = arY + (arH * minR / rows);
            const bw = arW * (maxC - minC + 1) / cols;
            const bh = arH * (maxR - minR + 1) / rows;
            ctx.strokeStyle = color; ctx.lineWidth = 2;
            ctx.strokeRect(Math.round(bx)+0.5, Math.round(by)+0.5, Math.round(bw)-1, Math.round(bh)-1);
            // Label name (top-left of bbox)
            const label = String(it.name || '');
            if (label){
              const tx = Math.round(bx) + 6; const ty = Math.round(by) + 14;
              ctx.font = '12px sans-serif';
              const m = ctx.measureText(label);
              ctx.fillStyle = 'rgba(0,0,0,0.55)';
              ctx.fillRect(tx-4, ty-12, Math.ceil(m.width)+8, 16);
              ctx.fillStyle = '#fff';
              ctx.fillText(label, tx, ty);
            }
          }
        });
      }
      // Draw full-frame grid and arena (hidden when Colors tab active)
      const cols = Math.max(1, Number(colsEl.value||1));
      const rows = Math.max(1, Number(rowsEl.value||1));
      // Arena rectangle and grid (if arena known)
      if (!isColors && state.tl && (state.br || hoverBR)){
        const brPoint = state.br || hoverBR;
        const x = state.tl.x * scaleX;
        const y = state.tl.y * scaleY;
        const w = Math.max(0, (brPoint.x - state.tl.x) * scaleX);
        const h = Math.max(0, (brPoint.y - state.tl.y) * scaleY);
        ctx.strokeStyle = '#4f8cff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);
        // draw grid inside the arena (same as Arena tab)
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 1;
        for (let i=-1; i<cols+2; i++){
          const gx = x + (w * i/cols);
          ctx.beginPath(); ctx.moveTo(Math.round(gx)+0.5, y - (h * 1/rows)); ctx.lineTo(Math.round(gx)+0.5, y + h + (h * 1/rows)); ctx.stroke();
        }
        for (let j=-1; j<rows+2; j++){
          const gy = y + (h * j/rows);
          ctx.beginPath(); ctx.moveTo(x - (w * 1/cols), Math.round(gy)+0.5); ctx.lineTo(x + w + (w * 1/cols), Math.round(gy)+0.5); ctx.stroke();
        }
        const wcm = Number(wcmEl.value||0), hcm = Number(hcmEl.value||0);
        if (wcm && hcm){
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x+6, y+6, 90, 18);
          ctx.fillStyle = '#fff';
          ctx.font = '12px sans-serif';
          ctx.fillText(`${wcm}×${hcm} cm`, x+10, y+19);
        }
        if (state.br){
          hTL.style.left = `${x}px`; hTL.style.top = `${y}px`; hTL.style.display = '';
          hBR.style.left = `${x + w}px`; hBR.style.top = `${y + h}px`; hBR.style.display = '';
        } else {
          hTL.style.display = 'none';
          hBR.style.display = 'none';
        }
      }
      // Hide handles when Colors is active
      if (isColors){ hTL.style.display = 'none'; hBR.style.display = 'none'; }
  }

    colsEl.addEventListener('change', drawOverlay);
    rowsEl.addEventListener('change', drawOverlay);
    wcmEl.addEventListener('change', drawOverlay);
    hcmEl.addEventListener('change', drawOverlay);

    // ROI adjacency helpers
    function cellKey(c){ return `${c.r},${c.c}`; }
    function isAdjacentToAny(list, cell){
      for (const c of (list||[])){
        const dr = Math.abs((c.r||0) - (cell.r||0));
        const dc = Math.abs((c.c||0) - (cell.c||0));
        if (dr + dc === 1) return true; // 4-neighbor adjacency
      }
      return false;
    }
    function isConnected(list){
      const arr = Array.isArray(list) ? list.slice() : [];
      if (arr.length <= 1) return true;
      const set = new Set(arr.map(cellKey));
      const q = [arr[0]];
      const seen = new Set([cellKey(arr[0])]);
      while (q.length){
        const cur = q.shift();
        const nbs = [
          { r: cur.r-1, c: cur.c },
          { r: cur.r+1, c: cur.c },
          { r: cur.r, c: cur.c-1 },
          { r: cur.r, c: cur.c+1 },
        ];
        for (const nb of nbs){
          const k = cellKey(nb);
          if (set.has(k) && !seen.has(k)){
            seen.add(k); q.push(nb);
          }
        }
      }
      return seen.size === set.size;
    }

    overlay.addEventListener('click', (ev) => {
      // Regions edit mode
      if (!marking && editingRoiIndex >= 0 && regionsState){
        if (!v.videoWidth || !v.videoHeight) return;
        const r = overlay.getBoundingClientRect();
        const sx = (ev.clientX - r.left) / r.width;
        const sy = (ev.clientY - r.top) / r.height;
        const px = Math.max(0, Math.min(v.videoWidth-1, Math.round(sx * v.videoWidth)));
        const py = Math.max(0, Math.min(v.videoHeight-1, Math.round(sy * v.videoHeight)));
        const cell = arenaCellAt(px, py);
        if (!cell) return;
        const cols = Math.max(1, Number(colsEl.value||1));
        const rows = Math.max(1, Number(rowsEl.value||1));
        if (cell.r < 0 || cell.c < 0 || cell.r >= rows || cell.c >= cols) return;
        const list = regionsState.items[editingRoiIndex].cells || [];
        const idx = list.findIndex(c => c.r===cell.r && c.c===cell.c);
        if (idx>=0){
          // Tentative removal; ensure remaining stays connected
          const next = list.filter((_,i)=>i!==idx);
          if (isConnected(next)){
            list.splice(idx, 1);
          } else {
            arenaStatus.textContent = 'Cells must remain connected';
          }
        } else {
          // Tentative add; must be adjacent to an existing cell (unless first)
          if (list.length === 0 || isAdjacentToAny(list, cell)){
            list.push({ r: cell.r, c: cell.c });
          } else {
            arenaStatus.textContent = 'New cells must touch existing selection';
          }
        }
        renderRoiUI();
        drawOverlay();
        updateChipColors();
        return;
      }
      if (!marking) return;
      if (!v.videoWidth || !v.videoHeight) return;
      const r = overlay.getBoundingClientRect();
      const sx = (ev.clientX - r.left) / r.width;
      const sy = (ev.clientY - r.top) / r.height;
      const px = Math.max(0, Math.min(v.videoWidth-1, Math.round(sx * v.videoWidth)));
      const py = Math.max(0, Math.min(v.videoHeight-1, Math.round(sy * v.videoHeight)));
      lastHandle = pickHandle(ev) || lastHandle;
      const p = snapCoord(px, py);
      if (!state.tl){
        state.tl = {x:p.x, y:p.y}; state.br = null;
      } else if (!state.br){
        state.br = {x:Math.max(p.x, state.tl.x), y:Math.max(p.y, state.tl.y)};
        drawOverlay();
        // finished marking -> auto-save and exit marking mode
        saveArena();
        marking = false; arenaMarkBtn.classList.remove('primary'); arenaMarkBtn.textContent = 'Mark';
      } else {
        state.tl = {x:p.x, y:p.y}; state.br = null;
      }
      drawOverlay();
      try { updateRegionsEnablement(); } catch {}
    });

    function pickHandle(ev){
      if (!state.tl || !state.br) return null;
      const rect = v.getBoundingClientRect();
      const scaleX = rect.width / v.videoWidth;
      const scaleY = rect.height / v.videoHeight;
      const x = state.tl.x * scaleX;
      const y = state.tl.y * scaleY;
      const w = (state.br.x - state.tl.x) * scaleX;
      const h = (state.br.y - state.tl.y) * scaleY;
      const s = 8;
      const mx = ev.clientX - overlay.getBoundingClientRect().left;
      const my = ev.clientY - overlay.getBoundingClientRect().top;
      function within(ax, ay){ return (mx >= ax - s) && (mx <= ax + s) && (my >= ay - s) && (my <= ay + s); }
      if (within(x, y)) return 'tl';
      if (within(x+w, y+h)) return 'br';
      return null;
    }
    let lastHandle = null;
    overlay.addEventListener('mousedown', (ev) => {
      // Colors: clicking can pick/drag tokens or place marks
      if (colorsPane && colorsPane.style.display !== 'none'){
        try{
          const rect = overlay.getBoundingClientRect();
          const ox = ev.clientX - rect.left, oy = ev.clientY - rect.top;
          // Compute drawn video rect
          const vw = v.videoWidth || 0, vh = v.videoHeight || 0;
          const tw = overlay.width, th = overlay.height;
          const vScale = (vw>0 && vh>0) ? Math.min(tw / vw, th / vh) : 1;
          const vDW = Math.round(vw * vScale), vDH = Math.round(vh * vScale);
          const vDX = Math.round((tw - vDW) / 2), vDY = Math.round((th - vDH) / 2);
          const curT = (v.currentTime||0);
          const dt = 1/Math.max(1, preprocFps||30);
          // First try to start dragging an existing token
          const pickRadius = 10; // px
          let bestIdx = -1, bestD2 = Infinity;
          for (let i=0;i<colorTokens.length;i++){
            const tkn = colorTokens[i];
            const dx = ox - tkn.x, dy = oy - tkn.y; const d2 = dx*dx + dy*dy;
            if (d2 < bestD2 && d2 <= pickRadius*pickRadius){ bestD2 = d2; bestIdx = i; }
          }
          if (bestIdx >= 0){ draggingMarkIdx = bestIdx; selectedMouse = colorTokens[bestIdx].mouse; updateColorsUI(); ev.preventDefault(); return; }

          // Shift-click removes mark for selected mouse in this frame
          if (ev.shiftKey){
            for (let i=colorMarks.length-1; i>=0; i--){
              const m = colorMarks[i];
              if (m.mouse === selectedMouse && Math.abs(m.t - curT) <= dt/2){ colorMarks.splice(i,1); }
            }
          renderColorsHistogram();
          drawOverlay();
          updateChipColors();
          return;
        }
          // Now, if segmentation is ready and click is inside video, place selected token
          if (!colorIndex || !colorIndexSize) return;
          if (ox < vDX || oy < vDY || ox >= vDX+vDW || oy >= vDY+vDH) return;
          const rx = (ox - vDX) / Math.max(1, vDW);
          const ry = (oy - vDY) / Math.max(1, vDH);
          const cx = Math.max(0, Math.min(colorIndexSize.w-1, Math.floor(rx * colorIndexSize.w)));
          const cy = Math.max(0, Math.min(colorIndexSize.h-1, Math.floor(ry * colorIndexSize.h)));
          const label = (colorIndex[cy] && colorIndex[cy][cx]) ? Number(colorIndex[cy][cx]) : 0;
          if (!label) return; // must click inside a cluster
          // Move selected token from its dock to this location and create a mark
          const tIdx = Math.max(0, Math.min(colorTokens.length-1, selectedMouse-1));
          colorTokens[tIdx].x = vDX + (cx / Math.max(1, colorIndexSize.w)) * vDW;
          colorTokens[tIdx].y = vDY + (cy / Math.max(1, colorIndexSize.h)) * vDH;
          colorTokens[tIdx].docked = false;
          // Replace any existing mark for this mouse at this frame
          for (let i=colorMarks.length-1; i>=0; i--){ const m = colorMarks[i]; if (m.mouse === selectedMouse && Math.abs(m.t - curT) <= dt/2){ colorMarks.splice(i,1); } }
          colorMarks.push({ mouse: selectedMouse, code: (miceCodes[selectedMouse-1]||'R'), x: cx, y: cy, t: curT, label });
          renderColorsHistogram();
          drawOverlay();
          updateChipColors();
        } catch {}
        return;
      }
      if (!marking) return; dragging = pickHandle(ev); lastHandle = dragging || lastHandle;
    });
    // Colors: hover detection, drag move and drop
    window.addEventListener('mousemove', (ev) => {
      if (!(colorsPane && colorsPane.style.display !== 'none')) return;
      try{
        const rect = overlay.getBoundingClientRect();
        const ox = ev.clientX - rect.left, oy = ev.clientY - rect.top;
        if (draggingMarkIdx < 0){
          // Hover detection
          let hi = -1; let bestD2 = Infinity; const pr = 10;
          for (let i=0;i<colorTokens.length;i++){
            const t = colorTokens[i]; const dx = ox - t.x, dy = oy - t.y; const d2 = dx*dx + dy*dy;
            if (d2 < bestD2 && d2 <= pr*pr){ bestD2 = d2; hi = i; }
          }
          if (hi !== hoverTokenIdx){ hoverTokenIdx = hi; drawOverlay(); }
          overlay.style.cursor = (hoverTokenIdx >= 0 ? 'grab' : '');
          return;
        }
        // Dragging (independent of segmentation readiness)
        const tkn = colorTokens[draggingMarkIdx];
        tkn.x = ox; tkn.y = oy; tkn.docked = false;
        overlay.style.cursor = 'grabbing';
        drawOverlay();
      } catch {}
    });
    window.addEventListener('mouseup', () => {
      if (!(colorsPane && colorsPane.style.display !== 'none')) return;
      if (draggingMarkIdx < 0) return;
      try{
        const tkn = colorTokens[draggingMarkIdx];
        const tw = overlay.width, th = overlay.height;
        const vw = v.videoWidth || 0, vh = v.videoHeight || 0;
        const vScale = (vw>0 && vh>0) ? Math.min(tw / vw, th / vh) : 1;
        const vDW = Math.round(vw * vScale), vDH = Math.round(vh * vScale);
        const vDX = Math.round((tw - vDW) / 2), vDY = Math.round((th - vDH) / 2);
        const inside = (tkn.x >= vDX && tkn.x < vDX+vDW && tkn.y >= vDY && tkn.y < vDY+vDH);
        const curT = (v.currentTime||0);
        const dt = 1/Math.max(1, preprocFps||30);
        for (let i=colorMarks.length-1; i>=0; i--){ const m = colorMarks[i]; if (m.mouse === colorTokens[draggingMarkIdx].mouse && Math.abs(m.t - curT) <= dt/2){ colorMarks.splice(i,1); } }
        if (inside){
          const cx = Math.max(0, Math.min(colorIndexSize.w-1, Math.floor(((tkn.x - vDX) / Math.max(1, vDW)) * colorIndexSize.w)));
          const cy = Math.max(0, Math.min(colorIndexSize.h-1, Math.floor(((tkn.y - vDY) / Math.max(1, vDH)) * colorIndexSize.h)));
          const label = (colorIndex && colorIndex[cy] && colorIndex[cy][cx]) ? Number(colorIndex[cy][cx]) : 0;
          if (label){
            colorMarks.push({ mouse: colorTokens[draggingMarkIdx].mouse, code: colorTokens[draggingMarkIdx].code, x: cx, y: cy, t: curT, label });
            colorTokens[draggingMarkIdx].docked = false;
          } else {
            colorTokens[draggingMarkIdx].x = colorTokens[draggingMarkIdx].homeX;
            colorTokens[draggingMarkIdx].y = colorTokens[draggingMarkIdx].homeY;
            colorTokens[draggingMarkIdx].docked = true;
          }
        } else {
          colorTokens[draggingMarkIdx].x = colorTokens[draggingMarkIdx].homeX;
          colorTokens[draggingMarkIdx].y = colorTokens[draggingMarkIdx].homeY;
          colorTokens[draggingMarkIdx].docked = true;
        }
        renderColorsHistogram();
      } catch {}
      draggingMarkIdx = -1;
      drawOverlay();
    });
    // Handle elements enable dragging even when not marking
    hTL.addEventListener('mousedown', (ev) => { ev.preventDefault(); dragging = 'tl'; lastHandle = 'tl'; });
    hBR.addEventListener('mousedown', (ev) => { ev.preventDefault(); dragging = 'br'; lastHandle = 'br'; });
    window.addEventListener('mouseup', () => { if (dragging) { dragging = null; if (state.tl && state.br) saveArena(); } });
    window.addEventListener('mousemove', (ev) => {
      if (!dragging) {
        if (!marking) return;
        // live preview while marking (TL chosen, BR pending)
        if (state.tl && !state.br){
          const r = overlay.getBoundingClientRect();
          const sx = (ev.clientX - r.left) / r.width;
          const sy = (ev.clientY - r.top) / r.height;
          const p = snapCoord(Math.round(sx * v.videoWidth), Math.round(sy * v.videoHeight));
          hoverBR = { x: Math.max(p.x, state.tl.x), y: Math.max(p.y, state.tl.y) };
          drawOverlay();
        }
        return;
      }
      const r = overlay.getBoundingClientRect();
      const sx = (ev.clientX - r.left) / r.width;
      const sy = (ev.clientY - r.top) / r.height;
      // ROI move drag removed
      const p = snapCoord(Math.round(sx * v.videoWidth), Math.round(sy * v.videoHeight));
      if (dragging === 'tl'){
        state.tl = {x: Math.min(p.x, state.br.x-1), y: Math.min(p.y, state.br.y-1)};
      } else if (dragging === 'br'){
        state.br = {x: Math.max(p.x, state.tl.x+1), y: Math.max(p.y, state.tl.y+1)};
      }
      drawOverlay();
    });
    overlay.addEventListener('mouseleave', () => { if (marking && !state.br){ hoverBR = null; drawOverlay(); } });

    // --- Filters ---
    let filterLoop = null;
    function stopFilter(){ if (filterLoop){ cancelAnimationFrame(filterLoop); filterLoop = null; } }
    function startHistEq(){
      processed.style.display = '';
      v.style.filter = '';
      const ctx = processed.getContext('2d');
      const step = () => {
        if (v.readyState >= 2 && processed.width > 0 && processed.height > 0){
          try{
            // Preserve aspect ratio when drawing to processed canvas
            const vw = v.videoWidth || 0, vh = v.videoHeight || 0;
            ctx.clearRect(0,0,processed.width, processed.height);
            if (vw>0 && vh>0){
              const scale = Math.min(processed.width / vw, processed.height / vh);
              const dw = Math.round(vw * scale);
              const dh = Math.round(vh * scale);
              const dx = Math.round((processed.width - dw)/2);
              const dy = Math.round((processed.height - dh)/2);
              ctx.drawImage(v, dx, dy, dw, dh);
            } else {
              ctx.drawImage(v, 0, 0, processed.width, processed.height);
            }
            const img = ctx.getImageData(0,0,processed.width, processed.height);
            histEqInPlace(img.data);
            ctx.putImageData(img, 0, 0);
          } catch(e) { /* ignore */ }
        }
        filterLoop = requestAnimationFrame(step);
      };
      step();
    }
    function histEqInPlace(pix){
      const n = pix.length/4;
      const hr = new Uint32Array(256), hg = new Uint32Array(256), hb = new Uint32Array(256);
      for (let i=0,p=0;i<n;i++,p+=4){ hr[pix[p]]++; hg[pix[p+1]]++; hb[pix[p+2]]++; }
      const cdr = new Uint32Array(256), cdg = new Uint32Array(256), cdb = new Uint32Array(256);
      let sr=0, sg=0, sb=0;
      for (let i=0;i<256;i++){ sr+=hr[i]; sg+=hg[i]; sb+=hb[i]; cdr[i]=sr; cdg[i]=sg; cdb[i]=sb; }
      let r0=0,g0=0,b0=0; while(r0<256 && cdr[r0]===0) r0++; while(g0<256 && cdg[g0]===0) g0++; while(b0<256 && cdb[b0]===0) b0++;
      const nPix = n;
      const lr = new Uint8Array(256), lg = new Uint8Array(256), lb = new Uint8Array(256);
      const dr = Math.max(1, nPix - cdr[r0]);
      const dg = Math.max(1, nPix - cdg[g0]);
      const db = Math.max(1, nPix - cdb[b0]);
      for (let i=0;i<256;i++){
        lr[i] = Math.max(0, Math.min(255, Math.round((cdr[i]-cdr[r0]) * 255 / dr)));
        lg[i] = Math.max(0, Math.min(255, Math.round((cdg[i]-cdg[g0]) * 255 / dg)));
        lb[i] = Math.max(0, Math.min(255, Math.round((cdb[i]-cdb[b0]) * 255 / db)));
      }
      for (let i=0,p=0;i<n;i++,p+=4){ pix[p]=lr[pix[p]]; pix[p+1]=lg[pix[p+1]]; pix[p+2]=lb[pix[p+2]]; }
    }
    function applyFilter(){
      stopFilter();
      const mode = filterSel.value;
      if (mode === 'none'){
        processed.style.display = 'none';
        v.style.filter = '';
      } else if (mode === 'invert'){
        processed.style.display = 'none';
        v.style.filter = 'invert(1)';
      } else if (mode === 'histeq'){
        startHistEq();
      }
    }
    filterSel.addEventListener('change', applyFilter);

    // Removed one-off MATLAB segmentation controls

    // --- Colors tab loop ---
    function stopColorsLoop(){
      colorsActive = false;
      if (colorsLoop){ cancelAnimationFrame(colorsLoop); colorsLoop = null; }
    }
    async function processColorsFrame(){
      if (!colorsActive) return;
      if (colorsInFlight) return;
      if (!v.videoWidth || !v.videoHeight) return;
      if (!hasBackground || !bgCanvas.width || !bgCanvas.height){ colorsStatus.textContent = 'No background'; return; }
      try{
        // Snapshot with max width 640
        const maxW = 640;
        const scale = Math.min(1, maxW / v.videoWidth);
        const w = Math.max(1, Math.round(v.videoWidth * scale));
        const h = Math.max(1, Math.round(v.videoHeight * scale));
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const cctx = c.getContext('2d');
        cctx.drawImage(v, 0, 0, w, h);
        const dataUrl = c.toDataURL('image/png');
        // Prepare background scaled to same size
        const cb = document.createElement('canvas'); cb.width = w; cb.height = h;
        const cbctx = cb.getContext('2d');
        cbctx.drawImage(bgCanvas, 0, 0, bgCanvas.width, bgCanvas.height, 0, 0, w, h);
        const bgUrl = cb.toDataURL('image/png');
        colorsInFlight = true; colorsLastTs = performance.now();
        const r = await fetch('/api/matlab/segment_colors', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ image: dataUrl, background: bgUrl }) });
        const d = await r.json();
        colorsInFlight = false;
        if (!r.ok || d.error){ colorsStatus.textContent = 'Error: ' + (d.error || r.statusText); return; }
        const idx = (Array.isArray(d.index) ? d.index : null);
        colorIndex = idx; colorIndexSize = { w, h };
        buildColorEdges();
        drawOverlay();
      } catch(e){ colorsInFlight = false; colorsStatus.textContent = 'Error: ' + e; }
    }
    function startColorsLoop(){
      colorsActive = true;
      // Prefer per-video-frame callback if available
      const useVFC = typeof v.requestVideoFrameCallback === 'function';
      if (useVFC){
        const onFrame = async () => {
          if (!colorsActive) return;
          await processColorsFrame();
          try { v.requestVideoFrameCallback(() => onFrame()); } catch { /* ignore */ }
        };
        try { v.requestVideoFrameCallback(() => onFrame()); } catch { /* ignore */ }
      } else {
        let lastT = -1;
        const step = async () => {
          if (!colorsActive) return;
          try{
            // Only process when time changes to approximate new frames
            if (v.currentTime !== lastT){
              lastT = v.currentTime;
              await processColorsFrame();
            }
          } finally {
            colorsLoop = requestAnimationFrame(step);
          }
        };
        colorsLoop = requestAnimationFrame(step);
      }
    }

  tabColors?.addEventListener('click', () => {
    if (tabColors.disabled) return;
    arenaPane.style.display='none';
    bgPane.style.display='none';
    regionsPane.style.display='none';
    colorsPane.style.display='';
    try{ colorsStatus.textContent = ''; } catch{}
    stopFilter(); // avoid conflicting processed canvas overlay
    stopColorsLoop(); startColorsLoop();
    try { processColorsFrame(); } catch {}
    dockAllTokens();
    setActivePreprocTab('colors');
    // Enable interactions for marking
    try { overlay.style.pointerEvents = 'auto'; } catch {}
    updateColorsUI();
    drawOverlay();
  });
    colorsSegments?.addEventListener('change', drawOverlay);
    colorsThicknessInput?.addEventListener('input', () => {
      try {
        colorEdgeThickness = Math.max(0, Math.min(8, Math.round(Number(colorsThicknessInput.value)||0)));
        if (colorsThicknessVal){ colorsThicknessVal.textContent = String(colorEdgeThickness); }
        try { localStorage.setItem('cheesepie.preproc.colors.edge_thickness', String(colorEdgeThickness)); } catch {}
        buildColorEdges();
        drawOverlay();
      } catch {}
    });
    document.getElementById('pp-colors-clear')?.addEventListener('click', () => {
      try { colorMarks.length = 0; } catch {}
      renderColorsHistogram();
      drawOverlay();
    });
    document.getElementById('pp-colors-remove')?.addEventListener('click', () => {
      try{
        const curT = (v.currentTime||0);
        const dt = 1/Math.max(1, preprocFps||30);
        for (let i=colorMarks.length-1; i>=0; i--){
          const m = colorMarks[i];
          if (m.mouse === selectedMouse && Math.abs(m.t - curT) <= dt/2){ colorMarks.splice(i,1); }
        }
      } catch {}
      renderColorsHistogram();
      drawOverlay();
    });

    function snapCoord(px, py){
      return { x: clamp(Math.round(px), 0, v.videoWidth-1), y: clamp(Math.round(py), 0, v.videoHeight-1) };
    }
    function clamp(val, a, b){ return Math.max(a, Math.min(b, val)); }

    // Helper: hex color to rgba string
    function hexToRgba(hex, a){
      const h = (hex||'').replace('#','');
      const r = parseInt(h.substring(0,2)||'0',16);
      const g = parseInt(h.substring(2,4)||'0',16);
      const b = parseInt(h.substring(4,6)||'0',16);
      return `rgba(${r},${g},${b},${a})`;
    }

    // Map video-space px,py to arena-aligned grid cell (r,c). Returns null if no arena or outside arena.
  function arenaCellAt(px, py){
    if (!(state.tl && state.br)) return null;
    const cols = Math.max(1, Number(colsEl.value||1));
    const rows = Math.max(1, Number(rowsEl.value||1));
    const ax = state.tl.x, ay = state.tl.y;
    const aw = (state.br.x - state.tl.x);
    const ah = (state.br.y - state.tl.y);
    if (aw <= 0 || ah <= 0) return null;
    const rx = px - ax, ry = py - ay;
    // Allow cells outside the arena by not clamping rx/ry
    const c = Math.floor(rx * cols / aw);
    const r = Math.floor(ry * rows / ah);
    return { r, c, cols, rows };
  }

    // ---- Regions helpers (global) ----
    function cellsFromCfg(ci){
      try{
        const raw = Array.isArray(ci?.cells) ? ci.cells : [];
        return raw.map(x => ({ r: Number(x?.[0])||0, c: Number(x?.[1])||0 }));
      } catch { return []; }
    }
    function defaultRegionsState(){
      const facs = (window.CHEESEPIE && window.CHEESEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
      const keys = Object.keys(facs);
      // Guess from video filename
      function parseCam(path){ try{ const m = String(path||'').match(/\.cam(\d{2})(?:\.|$)/i); return m? Number(m[1]) : null; }catch{return null;} }
      function parseExperiment(path){ try{ const base = String(path||'').split('/').pop()||''; const pre = base.split('.exp')[0]||''; const name = pre.split('-')[0]||pre; return String(name||'').toUpperCase(); }catch{return '';} }
      const camNo = parseCam(videoPath);
      const expName = parseExperiment(videoPath);
      let fac = '';
      if (keys.length){
        let best = { k: keys[0], score: -1 };
        keys.forEach(k => {
          const facCfg = facs[k]||{};
          const camList = Array.isArray(facCfg.camera_list) ? facCfg.camera_list : [];
          const hasCam = (camNo!=null) && camList.includes(camNo);
          const hasExp = !!(expName && (facCfg.experiments||{})[expName]);
          const score = (hasCam?2:0) + (hasExp?1:0);
          if (score > best.score) best = { k, score };
        });
        fac = best.k;
      }
      // Fallback to persisted choice if guess invalid
      try { const persisted = localStorage.getItem('cheesepie.preproc.facility') || ''; if (persisted && (persisted in facs)) fac = persisted; } catch {}
      if (!fac || !(fac in facs)) fac = keys[0] || '';
      const sets = (fac && facs[fac] && facs[fac].roi_sets) || [];
      // Prefer 'Default' setup; else persisted; else first
      let setName = '';
      const def = sets.find(s => (s && (s.name||'').toLowerCase()==='default'));
      if (def) setName = def.name;
      if (!setName){ try { const persistedSet = localStorage.getItem('cheesepie.preproc.setup') || ''; if (persistedSet && sets.find(s=>s.name===persistedSet)) setName = persistedSet; } catch {} }
      if (!setName) setName = (sets[0] && sets[0].name) || '';
      const sel = sets.find(s => s.name===setName) || sets[0] || { items: [] };
      const items = (sel.items || []).map(it => ({ name: it.name, enabled: !!it.enabled, sheltered: !!it.sheltered, cells: cellsFromCfg(it) }));
      return { facility: fac, set: setName, items };
    }
    function populateRoiFacility(){
      const facs = (window.CHEESEPIE && window.CHEESEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
      if (!roiFacilitySel) return;
      roiFacilitySel.innerHTML = '';
      Object.keys(facs).forEach(k => { const o = document.createElement('option'); o.value=k; o.textContent=k; roiFacilitySel.appendChild(o); });
    }
    function populateRoiSets(){
      const facs = (window.CHEESEPIE && window.CHEESEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
      if (!roiSetSel || !roiFacilitySel) return;
      const fac = roiFacilitySel.value;
      const sets = (fac && facs[fac] && facs[fac].roi_sets) || [];
      roiSetSel.innerHTML = '';
      // Rename ROI set => Setup in UI
      sets.forEach(s => { const o = document.createElement('option'); o.value = s.name; o.textContent = s.name || 'Setup'; roiSetSel.appendChild(o); });
    }
    function applySetupDefaults(){
      try{
        const facs = (window.CHEESEPIE && window.CHEESEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
        const fac = roiFacilitySel?.value || '';
        const setName = roiSetSel?.value || '';
        const sets = (fac && facs[fac] && facs[fac].roi_sets) || [];
        const set = sets.find(s => s.name === setName) || {};
        const pp = set.preproc || {};
        if (pp.grid_cols) colsEl.value = pp.grid_cols;
        if (pp.grid_rows) rowsEl.value = pp.grid_rows;
        if (pp.arena_width_cm) wcmEl.value = pp.arena_width_cm;
        if (pp.arena_height_cm) hcmEl.value = pp.arena_height_cm;
        if (pp.bg_frames) bgFramesEl.value = pp.bg_frames;
        if (pp.bg_quantile !== undefined) bgQuantEl.value = pp.bg_quantile;
        // Validate config-defined ROI connectivity and bounds; warn if not compliant
        const cols = Math.max(1, Number(colsEl.value||1));
        const rows = Math.max(1, Number(rowsEl.value||1));
        const bad = [];
        (set.items||[]).forEach(ci => {
          const cells = (ci.cells||[]).map(x => ({ r:Number(x?.[0])||0, c:Number(x?.[1])||0 }))
            .filter(c => c.r>=0 && c.c>=0 && c.r<rows && c.c<cols);
          if (cells.length>0 && !isConnected(cells)) bad.push(ci.name||'');
        });
        if (bad.length){ try{ showToast('Some setup ROIs are not connected: ' + bad.slice(0,3).join(', ') + (bad.length>3?'…':''), 'warn'); } catch{} }
      } catch {}
    }

    // Toast helper
    function showToast(msg, kind){
      try{
        const t = document.createElement('div');
        t.textContent = String(msg||'');
        const bg = kind==='error' ? 'rgba(220,53,69,0.95)' : (kind==='warn' ? 'rgba(255,193,7,0.95)' : 'rgba(33,37,41,0.95)');
        Object.assign(t.style, {
          position:'fixed', right:'16px', bottom:'16px', maxWidth:'420px', zIndex:'9999',
          padding:'10px 12px', borderRadius:'8px', color:'#fff', fontSize:'13px', boxShadow:'0 6px 18px rgba(0,0,0,0.25)',
          background:bg, opacity:'1'
        });
        document.body.appendChild(t);
        setTimeout(()=>{ try{ t.style.transition='opacity 300ms'; t.style.opacity='0'; }catch{} }, 2000);
        setTimeout(()=>{ try{ document.body.removeChild(t); }catch{} }, 2400);
      } catch {}
    }
    // Themed modal dialog (lazy-created)
    function showModal(title, message){
      try{
        let backdrop = document.getElementById('pp-modal-backdrop');
        let modal = document.getElementById('pp-modal');
        if (!backdrop){
          backdrop = document.createElement('div');
          backdrop.id = 'pp-modal-backdrop';
          backdrop.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;z-index:9998;';
          document.body.appendChild(backdrop);
        }
        if (!modal){
          modal = document.createElement('div');
          modal.id = 'pp-modal';
          modal.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:min(520px,92%);background:var(--panel);color:var(--text);border:1px solid var(--border);border-radius:10px;box-shadow:0 12px 28px rgba(0,0,0,0.35);z-index:9999;display:none;';
          modal.innerHTML = `
            <div style="padding:12px 16px; font-weight:600; border-bottom:1px solid var(--border)" id="pp-modal-title"></div>
            <div style="padding:14px 16px; white-space:pre-wrap" id="pp-modal-msg"></div>
            <div style="display:flex;justify-content:flex-end;gap:8px;padding:10px 16px;border-top:1px solid var(--border)">
              <button class="btn" id="pp-modal-ok">OK</button>
            </div>`;
          document.body.appendChild(modal);
          modal.querySelector('#pp-modal-ok').addEventListener('click', () => { try{ backdrop.style.display='none'; modal.style.display='none'; } catch{} });
          backdrop.addEventListener('click', () => { try{ backdrop.style.display='none'; modal.style.display='none'; } catch{} });
        }
        modal.querySelector('#pp-modal-title').textContent = String(title||'');
        modal.querySelector('#pp-modal-msg').textContent = String(message||'');
        backdrop.style.display = '';
        modal.style.display = '';
      } catch {}
    }

    async function onSaveSetup(){
      try{ setupStatus.textContent = ''; } catch {}
      const facility = roiFacilitySel?.value || '';
      const facs = (window.CHEESEPIE && window.CHEEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
      const sets = (((facs[facility]||{}).roi_sets)||[]);
      let setupName = (window.__ppSaveName || '').trim();
      if (setupName){ try { window.__ppSaveName = ''; } catch {} }
      else {
        // Ask for name; handle overwrite vs save-as-new
        try{
          let name = prompt('Setup name', roiSetSel?.value || 'Default');
          if (!name) return;
          name = name.trim();
          if (!name) return;
          const exists = sets.find(s => (s&&s.name)===name);
          if (exists){
            const doOverwrite = confirm(`Setup "${name}" already exists. Overwrite? Click Cancel to enter a new name.`);
            if (!doOverwrite){
              const alt = prompt('New setup name');
              if (!alt) return;
              setupName = alt.trim();
            } else {
              setupName = name;
            }
          } else {
            setupName = name;
          }
        } catch { return; }
      }
      // Validate ROI cells before save
      const cols = Math.max(1, Number(colsEl.value||1));
      const rows = Math.max(1, Number(rowsEl.value||1));
      for (const it of (regionsState?.items||[])){
        const cells = (it.cells||[]).map(c => ({ r:Number(c.r)||0, c:Number(c.c)||0 }));
        if (cells.some(c => c.r<0 || c.c<0 || c.r>=rows || c.c>=cols)){
          showToast(`ROI "${it.name}": contains out-of-bounds cells`, 'error');
          return;
        }
        if (cells.length>0 && !isConnected(cells)){
          showToast(`ROI "${it.name}": cells must be connected`, 'error');
          return;
        }
      }
      const payload = {
        facility,
        setup_name: setupName,
        preproc: {
          arena_width_cm: Math.max(0, Number(wcmEl.value||0)),
          arena_height_cm: Math.max(0, Number(hcmEl.value||0)),
          grid_cols: Math.max(1, Number(colsEl.value||1)),
          grid_rows: Math.max(1, Number(rowsEl.value||1)),
          bg_frames: Math.max(1, Number(bgFramesEl.value||1)),
          bg_quantile: Math.max(0, Math.min(100, Number(bgQuantEl.value||0)))
        },
        items: (regionsState?.items||[]).map(it => ({
          name: it.name,
          enabled: !!it.enabled,
          sheltered: !!it.sheltered,
          cells: (it.cells||[]).map(c => [Number(c.r)||0, Number(c.c)||0])
        }))
      };
      try{
        const r = await fetch('/api/preproc/setup/save', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const d = await r.json();
        if (!r.ok || d.error){ setupStatus.textContent = 'Error: ' + (d.error || r.statusText); return; }
        // Update local config mirror so UI stays in sync without reload
        const facs = (window.CHEESEPIE && window.CHEESEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
        const fac = facs[facility] || (facs[facility] = { roi_sets: [] });
        const sets = fac.roi_sets || (fac.roi_sets = []);
        const idx = sets.findIndex(s => (s && s.name) === setupName);
        const newSetup = { name: setupName, preproc: payload.preproc, items: payload.items };
        if (idx >= 0) sets[idx] = newSetup; else sets.push(newSetup);
        populateRoiSets();
        roiSetSel.value = setupName;
        try { localStorage.setItem('cheesepie.preproc.setup', setupName); } catch {}
        applySetupDefaults();
        renderRoiUI();
        drawOverlay();
        setupStatus.textContent = 'Setup saved';
      } catch(e){ setupStatus.textContent = 'Error: ' + e; }
    }
    function renderRoiUI(){
      const facs = (window.CHEESEPIE && window.CHEESEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
      if (!regionsState) regionsState = defaultRegionsState();
      populateRoiFacility();
      if (regionsState.facility) roiFacilitySel.value = regionsState.facility;
      populateRoiSets();
      if (regionsState.set) roiSetSel.value = regionsState.set;
      try { localStorage.setItem('cheesepie.preproc.facility', roiFacilitySel.value||''); } catch {}
      try { localStorage.setItem('cheesepie.preproc.setup', roiSetSel.value||''); } catch {}
      applySetupDefaults();
      const cfgItems = (((facs[roiFacilitySel.value]||{}).roi_sets||[]).find(s => s.name===roiSetSel.value)||{}).items || [];
      const map = new Map((regionsState.items||[]).map(it => [it.name, it]));
      regionsState.facility = roiFacilitySel.value; regionsState.set = roiSetSel.value;
      regionsState.items = cfgItems.map(ci => ({ name: ci.name, enabled: map.get(ci.name)?.enabled ?? !!ci.enabled, sheltered: map.get(ci.name)?.sheltered ?? !!ci.sheltered, cells: (map.get(ci.name)?.cells && map.get(ci.name).cells.length ? map.get(ci.name).cells : cellsFromCfg(ci)) }));
      // Table
      if (!roiTableBody) return;
      roiTableBody.innerHTML = '';
      regionsState.items.forEach((it, idx) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td style="padding:6px">${it.name}</td>
          <td style="padding:6px"><input type="checkbox" ${it.enabled?'checked':''} data-field="enabled"></td>
          <td style="padding:6px"><input type="checkbox" ${it.sheltered?'checked':''} data-field="sheltered"></td>
          <td style="padding:6px">${it.cells.length}</td>
          <td style="padding:6px"><button class="btn mini" data-edit="1">${editingRoiIndex===idx?'Stop':'Edit'}</button></td>
        `;
        tr.querySelector('[data-field="enabled"]').addEventListener('change', (e)=>{ regionsState.items[idx].enabled = e.target.checked; drawOverlay(); });
        tr.querySelector('[data-field="sheltered"]').addEventListener('change', (e)=>{ regionsState.items[idx].sheltered = e.target.checked; drawOverlay(); });
        tr.querySelector('[data-edit]').addEventListener('click', ()=>{ editingRoiIndex = (editingRoiIndex===idx ? -1 : idx); renderRoiUI(); drawOverlay(); });
        roiTableBody.appendChild(tr);
      });
      try { updateRegionsEnablement(); } catch {}
    }

    window.addEventListener('keydown', (ev) => {
      if (!state.tl || !state.br || !lastHandle) return;
      const step = ev.shiftKey ? 10 : 1;
      let dx = 0, dy = 0;
      if (ev.key === 'ArrowLeft') dx = -step;
      else if (ev.key === 'ArrowRight') dx = step;
      else if (ev.key === 'ArrowUp') dy = -step;
      else if (ev.key === 'ArrowDown') dy = step;
      else return;
      ev.preventDefault();
      const h = lastHandle;
      const cur = { x: h==='tl'?state.tl.x:state.br.x, y: h==='tl'?state.tl.y:state.br.y };
      let nx = cur.x + dx, ny = cur.y + dy;
      const p = snapCoord(nx, ny);
      if (h === 'tl'){
        state.tl = { x: clamp(p.x, 0, state.br.x-1), y: clamp(p.y, 0, state.br.y-1) };
      } else {
        state.br = { x: clamp(p.x, state.tl.x+1, v.videoWidth-1), y: clamp(p.y, state.tl.y+1, v.videoHeight-1) };
      }
      drawOverlay();
    });

    arenaMarkBtn.addEventListener('click', () => {
      marking = !marking;
      if (marking){
        state.tl = null; state.br = null; hoverBR = null; lastHandle = null; dragging = null;
        arenaStatus.textContent = 'Marking: click top-left then bottom-right';
        arenaMarkBtn.classList.add('primary');
        arenaMarkBtn.textContent = 'Marking…';
        overlay.style.pointerEvents = 'auto';
      } else {
        arenaStatus.textContent = '';
        arenaMarkBtn.classList.remove('primary');
        arenaMarkBtn.textContent = 'Mark';
        overlay.style.pointerEvents = 'none';
      }
      drawOverlay();
    });

    async function saveArena(){
      if (!videoPath || !state.tl || !state.br) return;
      const payload = {
        video: videoPath,
        arena: {
          tl: state.tl, br: state.br,
          cols: Math.max(1, Number(colsEl.value||1)),
          rows: Math.max(1, Number(rowsEl.value||1)),
          width_cm: Math.max(0, Number(wcmEl.value||0)),
          height_cm: Math.max(0, Number(hcmEl.value||0)),
        }
      };
      arenaStatus.textContent = 'Saving…';
      try{
        const r = await fetch('/api/preproc/arena', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const d = await r.json();
        if (!r.ok || d.error){ arenaStatus.textContent = 'Error: ' + (d.error || r.statusText); }
<<<<<<< Updated upstream
        else { arenaStatus.textContent = 'Saved'; try { updateRegionsEnablement(); } catch {} }
=======
        else { arenaStatus.textContent = 'Saved'; updateChipColors(); }
>>>>>>> Stashed changes
      } catch(e){ arenaStatus.textContent = 'Error: ' + e; }
    }

  tabArena.addEventListener('click', () => {
    if (tabArena.disabled) return;
    arenaPane.style.display=''; bgPane.style.display='none'; regionsPane.style.display='none'; colorsPane.style.display='none';
    if (!marking) overlay.style.pointerEvents = 'none';
    stopColorsLoop();
    setActivePreprocTab('arena');
    drawOverlay();
  });
  tabBg.addEventListener('click', () => {
    if (tabBg.disabled) return;
    arenaPane.style.display='none'; bgPane.style.display=''; regionsPane.style.display='none'; colorsPane.style.display='none';
    if (!marking) overlay.style.pointerEvents = 'none';
    stopColorsLoop();
    setActivePreprocTab('background');
    drawOverlay();
  });
  tabRegions.addEventListener('click', () => {
    if (tabRegions.disabled) return;
    const haveArena = !!(state.tl && state.br);
    if (!haveArena){ arenaStatus.textContent = 'Please mark the arena first to use Regions.'; }
    arenaPane.style.display='none'; bgPane.style.display='none'; regionsPane.style.display=''; colorsPane.style.display='none';
    overlay.style.pointerEvents = haveArena ? 'auto' : 'none';
    stopColorsLoop();
    setActivePreprocTab('regions');
    updateRegionsEnablement();
    drawOverlay();
  });
  tabSave.addEventListener('click', () => {
    if (tabSave.disabled) return;
    arenaPane.style.display='none'; bgPane.style.display='none'; regionsPane.style.display='none'; colorsPane.style.display='none'; savePane.style.display='';
    if (!marking) overlay.style.pointerEvents = 'none';
    stopColorsLoop();
    setActivePreprocTab('save');
    drawOverlay();
  });
    // persist active preproc step
    tabArena.addEventListener('click', () => { try { localStorage.setItem('cheesepie.preproc.step', 'arena'); } catch {} });
    tabBg.addEventListener('click', () => { try { localStorage.setItem('cheesepie.preproc.step', 'background'); } catch {} });
    tabRegions.addEventListener('click', () => { try { localStorage.setItem('cheesepie.preproc.step', 'regions'); } catch {} });
    tabColors?.addEventListener('click', () => { try { localStorage.setItem('cheesepie.preproc.step', 'colors'); } catch {} });
    tabSave?.addEventListener('click', () => { try { localStorage.setItem('cheesepie.preproc.step', 'save'); } catch {} });

    // Background computation
    bgRunBtn.addEventListener('click', async () => {
      if (!v.duration || !v.videoWidth){ bgStatus.textContent = 'Video not ready'; return; }
      const N = Math.max(5, Math.min(200, Number(bgFramesEl.value || 25)));
      const qPct = Math.max(0, Math.min(100, Number(bgQuantEl.value || 50)));
      bgStatus.textContent = `Sampling ${N} frames…`;
      await computeBackground(N, qPct/100);
      // Mark background as available
      try { hasBackground = bgCanvas && bgCanvas.width>0 && bgCanvas.height>0; updateTabEnablement(); loadDayGroup(); } catch {}
    });

    bgSaveBtn.addEventListener('click', async () => {
      if (!videoPath){ bgStatus.textContent = 'Missing video'; return; }
      const ctx = bgCanvas.getContext('2d');
      if (!bgCanvas.width || !bgCanvas.height){ bgStatus.textContent = 'No background to save'; return; }
      try{
        const dataUrl = bgCanvas.toDataURL('image/png');
        const r = await fetch('/api/preproc/background', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ video: videoPath, image: dataUrl }) });
        const d = await r.json();
        if (!r.ok || d.error){ bgStatus.textContent = 'Error: ' + (d.error || r.statusText); }
        else { bgStatus.textContent = 'Saved'; }
      } catch(e){ bgStatus.textContent = 'Error: ' + e; }
    });

    async function computeBackground(nFrames, quant){
      // Work at <= 640px width for performance
      const maxW = 640;
      const scale = Math.min(1, maxW / v.videoWidth);
      const w = Math.max(1, Math.round(v.videoWidth * scale));
      const h = Math.max(1, Math.round(v.videoHeight * scale));
      const work = document.createElement('canvas'); work.width = w; work.height = h;
      const wctx = work.getContext('2d');
      const frames = [];
      const times = new Set();
      for (let i=0;i<nFrames;i++){
        const t = Math.random() * Math.max(0.1, v.duration - 0.1);
        times.add(t);
      }
      const arrTimes = Array.from(times).slice(0, nFrames).sort((a,b)=>a-b);
      let captured = 0;
      for (const t of arrTimes){
        await new Promise((resolve) => {
          const onSeeked = () => {
            try{
              wctx.drawImage(v, 0, 0, w, h);
              const id = wctx.getImageData(0,0,w,h);
              frames.push(id.data);
              captured++;
              bgStatus.textContent = `Captured ${captured}/${arrTimes.length} frames…`;
            }catch{}
            v.removeEventListener('seeked', onSeeked);
            resolve();
          };
          v.addEventListener('seeked', onSeeked);
          try{ v.currentTime = Math.min(Math.max(0.05, t), Math.max(0.05, v.duration-0.05)); } catch{ v.removeEventListener('seeked', onSeeked); resolve(); }
        });
      }
      if (frames.length === 0){ bgStatus.textContent = 'No frames captured'; return; }
      // Compute per-pixel quantile across frames
      bgStatus.textContent = 'Computing background…';
      const out = new Uint8ClampedArray(w*h*4);
      const K = frames.length;
      const qi = Math.max(0, Math.min(K-1, Math.round(quant * (K-1))));
      for (let i=0, p=0; i<w*h; i++, p+=4){
        // Gather channel arrays
        const r = new Uint8Array(K), g = new Uint8Array(K), b = new Uint8Array(K), a = new Uint8Array(K);
        for (let k=0;k<K;k++){
          const f = frames[k];
          r[k] = f[p]; g[k] = f[p+1]; b[k] = f[p+2]; a[k] = f[p+3];
        }
        r.sort(); g.sort(); b.sort(); a.sort();
        out[p] = r[qi]; out[p+1] = g[qi]; out[p+2] = b[qi]; out[p+3] = 255;
      }
      const ctx = bgCanvas.getContext('2d');
      bgCanvas.width = w; bgCanvas.height = h;
      const img = new ImageData(out, w, h);
      ctx.putImageData(img, 0, 0);
      bgStatus.textContent = `Done (frames=${K}, q=${Math.round(quant*100)}%)`;
    }

    // Load existing preproc state
    (async function initLoad(){
      if (!videoPath) return;
      // restore last step
      try {
        const step = (urlStep || localStorage.getItem('cheesepie.preproc.step') || 'arena');
        if (step === 'colors'){
          arenaPane.style.display='none'; bgPane.style.display='none'; regionsPane.style.display='none'; colorsPane.style.display='';
          stopFilter();
          stopColorsLoop(); startColorsLoop();
          setActivePreprocTab('colors');
          try { overlay.style.pointerEvents = 'auto'; } catch {}
        } else if (step === 'save'){
          arenaPane.style.display='none'; bgPane.style.display='none'; regionsPane.style.display='none'; colorsPane.style.display='none'; savePane.style.display='';
          stopColorsLoop();
          setActivePreprocTab('save');
        } else if (step === 'regions' && !(state.tl && state.br)){
          arenaPane.style.display=''; bgPane.style.display='none'; regionsPane.style.display='none';
          setActivePreprocTab('arena');
        } else if (step === 'regions'){
          arenaPane.style.display='none'; bgPane.style.display='none'; regionsPane.style.display=''; colorsPane.style.display='none';
          overlay.style.pointerEvents = 'auto';
          setActivePreprocTab('regions');
        } else if (step === 'background'){
          arenaPane.style.display='none'; bgPane.style.display=''; regionsPane.style.display='none'; colorsPane.style.display='none';
          setActivePreprocTab('background');
        } else {
          arenaPane.style.display=''; bgPane.style.display='none'; regionsPane.style.display='none'; colorsPane.style.display='none';
          setActivePreprocTab('arena');
        }
        drawOverlay();
      } catch {}
      try{
        const r = await fetch(`/api/preproc/state?video=${encodeURIComponent(videoPath)}`);
        const d = await r.json();
        if (r.ok && d && d.ok){
          if (d.arena){
            const a = d.arena;
            state.tl = a.tl || null; state.br = a.br || null;
            if (a.cols) colsEl.value = a.cols;
            if (a.rows) rowsEl.value = a.rows;
            if (a.width_cm) wcmEl.value = a.width_cm;
            if (a.height_cm) hcmEl.value = a.height_cm;
            drawOverlay();
          }
          if (d.background){
            const img = new Image();
            img.onload = () => {
              bgCanvas.width = img.width; bgCanvas.height = img.height;
              const c = bgCanvas.getContext('2d'); c.drawImage(img, 0, 0);
              hasBackground = true; updateTabEnablement(); updateChipColors();
            };
            img.src = `/media?path=${encodeURIComponent(d.background)}`;
          }
          // Regions: apply loaded state to existing UI
          if (d.regions) {
            regionsState = d.regions;
          }
          // Colors: load saved marks
          try{
            if (d.colors && Array.isArray(d.colors.marks)){
              colorMarks.splice(0, colorMarks.length, ...d.colors.marks.map(m => ({ mouse:Number(m.mouse)||1, code:String(m.code||'')||miceCodes[(Number(m.mouse)||1)-1]||'R', x:Number(m.x)||0, y:Number(m.y)||0, t:Number(m.t)||0, label:Number(m.label)||0 })));
              renderColorsHistogram();
            }
          } catch {}
          renderRoiUI();
          drawOverlay();
          updateTabEnablement();
          updateChipColors();
        }
      } catch {}
    })();

    function updateTabEnablement(){
      try{
        const facs = (window.CHEESEPIE && window.CHEESEPIE.importer && window.CHEESEPIE.importer.facilities) || {};
        const fac = roiFacilitySel?.value || '';
        const sets = (fac && facs[fac] && facs[fac].roi_sets) || [];
        const hasSetup = !!(roiSetSel && roiSetSel.value && sets.some(s => s && s.name === roiSetSel.value));
        [tabArena, tabBg, tabRegions, tabColors, tabSave].forEach(btn => { if (btn){ btn.disabled = !hasSetup; btn.title = hasSetup ? '' : 'Select a Facility and Setup first'; }});
        // Colors requires background
        if (tabColors){ tabColors.disabled = tabColors.disabled || !hasBackground; tabColors.title = (!hasSetup ? 'Select a Facility and Setup first' : (!hasBackground ? 'Compute or load a background first' : '')); }
        // Update Regions table enablement
        try { updateRegionsEnablement(); } catch {}
      } catch {}
    }

    function updateRegionsEnablement(){
      try{
        const table = document.getElementById('roi-table');
        const note = document.getElementById('regions-disabled-note');
        const enabled = !!(state.tl && state.br);
        if (!enabled) { editingRoiIndex = -1; }
        if (note) note.style.display = enabled ? 'none' : '';
        if (table){ Array.from(table.querySelectorAll('input, button')).forEach(el => { el.disabled = !enabled; }); }
      } catch {}
    }
  });
</script>
{% endblock %}
